{
  "version": 3,
  "sources": ["../../@zarrita/storage/src/util.ts", "../../@zarrita/storage/src/fetch.ts", "../../zarrita/src/typedarray.ts", "../../zarrita/src/util.ts", "../../zarrita/src/codecs/bitround.ts", "../../zarrita/src/codecs/bytes.ts", "../../zarrita/src/codecs/crc32c.ts", "../../zarrita/src/codecs/gzip.ts", "../../zarrita/src/codecs/json2.ts", "../../zarrita/src/codecs/transpose.ts", "../../zarrita/src/codecs/vlen-utf8.ts", "../../zarrita/src/codecs/zlib.ts", "../../zarrita/src/codecs.ts", "../../zarrita/src/errors.ts", "../../zarrita/src/consolidated.ts", "../../zarrita/src/codecs/sharding.ts", "../../zarrita/src/hierarchy.ts", "../../zarrita/src/create.ts", "../../zarrita/src/indexing/util.ts", "../../zarrita/src/indexing/indexer.ts", "../../zarrita/src/indexing/get.ts", "../../zarrita/src/indexing/set.ts", "../../zarrita/src/indexing/ops.ts", "../../zarrita/src/open.ts"],
  "sourcesContent": ["import type { AbsolutePath } from \"./types.js\";\r\n\r\nexport function strip_prefix<Path extends AbsolutePath>(\r\n\tpath: Path,\r\n): Path extends AbsolutePath<infer Rest> ? Rest : never {\r\n\t// @ts-expect-error - TS can't infer this type correctly\r\n\treturn path.slice(1);\r\n}\r\n\r\nexport function uri2href(url: string | URL) {\r\n\tlet [protocol, rest] = (typeof url === \"string\" ? url : url.href).split(\r\n\t\t\"://\",\r\n\t);\r\n\tif (protocol === \"https\" || protocol === \"http\") {\r\n\t\treturn url;\r\n\t}\r\n\tif (protocol === \"gc\") {\r\n\t\treturn `https://storage.googleapis.com/${rest}`;\r\n\t}\r\n\tif (protocol === \"s3\") {\r\n\t\treturn `https://s3.amazonaws.com/${rest}`;\r\n\t}\r\n\tthrow Error(`Protocol not supported, got: ${JSON.stringify(protocol)}`);\r\n}\r\n\r\nexport function fetch_range(\r\n\turl: string | URL,\r\n\toffset?: number,\r\n\tlength?: number,\r\n\topts: RequestInit = {},\r\n) {\r\n\tif (offset !== undefined && length !== undefined) {\r\n\t\t// merge request opts\r\n\t\topts = {\r\n\t\t\t...opts,\r\n\t\t\theaders: {\r\n\t\t\t\t...opts.headers,\r\n\t\t\t\tRange: `bytes=${offset}-${offset + length - 1}`,\r\n\t\t\t},\r\n\t\t};\r\n\t}\r\n\treturn fetch(url, opts);\r\n}\r\n\r\nexport function merge_init(\r\n\tstoreOverrides: RequestInit,\r\n\trequestOverrides: RequestInit,\r\n) {\r\n\t// Request overrides take precedence over storeOverrides.\r\n\treturn {\r\n\t\t...storeOverrides,\r\n\t\t...requestOverrides,\r\n\t\theaders: {\r\n\t\t\t...storeOverrides.headers,\r\n\t\t\t...requestOverrides.headers,\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Make an assertion.\r\n *\r\n * Usage\r\n * @example\r\n * ```ts\r\n * const value: boolean = Math.random() <= 0.5;\r\n * assert(value, \"value is greater than than 0.5!\");\r\n * value // true\r\n * ```\r\n *\r\n * @param expression - The expression to test.\r\n * @param msg - The optional message to display if the assertion fails.\r\n * @throws an {@link Error} if `expression` is not truthy.\r\n */\r\nexport function assert(\r\n\texpression: unknown,\r\n\tmsg: string | undefined = \"\",\r\n): asserts expression {\r\n\tif (!expression) throw new Error(msg);\r\n}\r\n", "import type { AbsolutePath, AsyncReadable, RangeQuery } from \"./types.js\";\r\nimport { fetch_range, merge_init } from \"./util.js\";\r\n\r\nfunction resolve(root: string | URL, path: AbsolutePath): URL {\r\n\tconst base = typeof root === \"string\" ? new URL(root) : root;\r\n\tif (!base.pathname.endsWith(\"/\")) {\r\n\t\t// ensure trailing slash so that base is resolved as _directory_\r\n\t\tbase.pathname += \"/\";\r\n\t}\r\n\tconst resolved = new URL(path.slice(1), base);\r\n\t// copy search params to new URL\r\n\tresolved.search = base.search;\r\n\treturn resolved;\r\n}\r\n\r\nasync function handle_response(\r\n\tresponse: Response,\r\n): Promise<Uint8Array | undefined> {\r\n\tif (response.status === 404) {\r\n\t\treturn undefined;\r\n\t}\r\n\tif (response.status === 200 || response.status === 206) {\r\n\t\treturn new Uint8Array(await response.arrayBuffer());\r\n\t}\r\n\tthrow new Error(\r\n\t\t`Unexpected response status ${response.status} ${response.statusText}`,\r\n\t);\r\n}\r\n\r\nasync function fetch_suffix(\r\n\turl: URL,\r\n\tsuffix_length: number,\r\n\tinit: RequestInit,\r\n\tuse_suffix_request: boolean,\r\n): Promise<Response> {\r\n\tif (use_suffix_request) {\r\n\t\treturn fetch(url, {\r\n\t\t\t...init,\r\n\t\t\theaders: { ...init.headers, Range: `bytes=-${suffix_length}` },\r\n\t\t});\r\n\t}\r\n\tlet response = await fetch(url, { ...init, method: \"HEAD\" });\r\n\tif (!response.ok) {\r\n\t\t// will be picked up by handle_response\r\n\t\treturn response;\r\n\t}\r\n\tlet content_length = response.headers.get(\"Content-Length\");\r\n\tlet length = Number(content_length);\r\n\treturn fetch_range(url, length - suffix_length, length, init);\r\n}\r\n\r\n/**\r\n * Readonly store based in the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\r\n * Must polyfill `fetch` for use in Node.js.\r\n *\r\n * ```typescript\r\n * import * as zarr from \"zarrita\";\r\n * const store = new FetchStore(\"http://localhost:8080/data.zarr\");\r\n * const arr = await zarr.get(store, { kind: \"array\" });\r\n * ```\r\n */\r\nclass FetchStore implements AsyncReadable<RequestInit> {\r\n\t#overrides: RequestInit;\r\n\t#use_suffix_request: boolean;\r\n\r\n\tconstructor(\r\n\t\tpublic url: string | URL,\r\n\t\toptions: { overrides?: RequestInit; useSuffixRequest?: boolean } = {},\r\n\t) {\r\n\t\tthis.#overrides = options.overrides ?? {};\r\n\t\tthis.#use_suffix_request = options.useSuffixRequest ?? false;\r\n\t}\r\n\r\n\t#merge_init(overrides: RequestInit) {\r\n\t\treturn merge_init(this.#overrides, overrides);\r\n\t}\r\n\r\n\tasync get(\r\n\t\tkey: AbsolutePath,\r\n\t\toptions: RequestInit = {},\r\n\t): Promise<Uint8Array | undefined> {\r\n\t\tlet href = resolve(this.url, key).href;\r\n\t\tlet response = await fetch(href, this.#merge_init(options));\r\n\t\treturn handle_response(response);\r\n\t}\r\n\r\n\tasync getRange(\r\n\t\tkey: AbsolutePath,\r\n\t\trange: RangeQuery,\r\n\t\toptions: RequestInit = {},\r\n\t): Promise<Uint8Array | undefined> {\r\n\t\tlet url = resolve(this.url, key);\r\n\t\tlet init = this.#merge_init(options);\r\n\t\tlet response: Response;\r\n\t\tif (\"suffixLength\" in range) {\r\n\t\t\tresponse = await fetch_suffix(\r\n\t\t\t\turl,\r\n\t\t\t\trange.suffixLength,\r\n\t\t\t\tinit,\r\n\t\t\t\tthis.#use_suffix_request,\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tresponse = await fetch_range(url, range.offset, range.length, init);\r\n\t\t}\r\n\t\treturn handle_response(response);\r\n\t}\r\n}\r\n\r\nexport default FetchStore;\r\n", "/**\r\n * Custom array-like views (i.e., TypedArrays) for Zarr binary data buffers.\r\n *\r\n * @module\r\n */\r\n\r\n/**\r\n * An array-like view of a fixed-length boolean buffer.\r\n *\r\n * Encoded as 1 byte per value.\r\n */\r\nexport class BoolArray {\r\n\t#bytes: Uint8Array;\r\n\r\n\tconstructor(size: number);\r\n\tconstructor(arr: Iterable<boolean>);\r\n\tconstructor(buffer: ArrayBuffer, byteOffset?: number, length?: number);\r\n\tconstructor(\r\n\t\tx: number | Iterable<boolean> | ArrayBuffer,\r\n\t\tbyteOffset?: number,\r\n\t\tlength?: number,\r\n\t) {\r\n\t\tif (typeof x === \"number\") {\r\n\t\t\tthis.#bytes = new Uint8Array(x);\r\n\t\t} else if (x instanceof ArrayBuffer) {\r\n\t\t\tthis.#bytes = new Uint8Array(x, byteOffset, length);\r\n\t\t} else {\r\n\t\t\tthis.#bytes = new Uint8Array(Array.from(x, (v) => (v ? 1 : 0)));\r\n\t\t}\r\n\t}\r\n\r\n\tget BYTES_PER_ELEMENT(): 1 {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tget byteOffset(): number {\r\n\t\treturn this.#bytes.byteOffset;\r\n\t}\r\n\r\n\tget byteLength(): number {\r\n\t\treturn this.#bytes.byteLength;\r\n\t}\r\n\r\n\tget buffer(): ArrayBuffer {\r\n\t\treturn this.#bytes.buffer as ArrayBuffer;\r\n\t}\r\n\r\n\tget length(): number {\r\n\t\treturn this.#bytes.length;\r\n\t}\r\n\r\n\tget(idx: number): boolean {\r\n\t\tlet value = this.#bytes[idx];\r\n\t\treturn typeof value === \"number\" ? value !== 0 : value;\r\n\t}\r\n\r\n\tset(idx: number, value: boolean): void {\r\n\t\tthis.#bytes[idx] = value ? 1 : 0;\r\n\t}\r\n\r\n\tfill(value: boolean): void {\r\n\t\tthis.#bytes.fill(value ? 1 : 0);\r\n\t}\r\n\r\n\t*[Symbol.iterator](): IterableIterator<boolean> {\r\n\t\tfor (let i = 0; i < this.length; i++) {\r\n\t\t\tyield this.get(i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * An array-like view of a fixed-length byte buffer.\r\n *\r\n * Encodes a raw byte sequences without enforced encoding.\r\n */\r\nexport class ByteStringArray {\r\n\t_data: Uint8Array;\r\n\tchars: number;\r\n\t#encoder: TextEncoder;\r\n\r\n\tconstructor(chars: number, size: number);\r\n\tconstructor(\r\n\t\tchars: number,\r\n\t\tbuffer: ArrayBuffer,\r\n\t\tbyteOffset?: number,\r\n\t\tlength?: number,\r\n\t);\r\n\tconstructor(chars: number, arr: Iterable<string>);\r\n\tconstructor(\r\n\t\tchars: number,\r\n\t\tx: number | ArrayBuffer | Iterable<string>,\r\n\t\tbyteOffset?: number,\r\n\t\tlength?: number,\r\n\t) {\r\n\t\tthis.chars = chars;\r\n\t\tthis.#encoder = new TextEncoder();\r\n\t\tif (typeof x === \"number\") {\r\n\t\t\tthis._data = new Uint8Array(x * chars);\r\n\t\t} else if (x instanceof ArrayBuffer) {\r\n\t\t\tif (length) length = length * chars;\r\n\t\t\tthis._data = new Uint8Array(x, byteOffset, length);\r\n\t\t} else {\r\n\t\t\tlet values = Array.from(x);\r\n\t\t\tthis._data = new Uint8Array(values.length * chars);\r\n\t\t\tfor (let i = 0; i < values.length; i++) {\r\n\t\t\t\tthis.set(i, values[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tget BYTES_PER_ELEMENT(): number {\r\n\t\treturn this.chars;\r\n\t}\r\n\r\n\tget byteOffset(): number {\r\n\t\treturn this._data.byteOffset;\r\n\t}\r\n\r\n\tget byteLength(): number {\r\n\t\treturn this._data.byteLength;\r\n\t}\r\n\r\n\tget buffer(): ArrayBuffer {\r\n\t\treturn this._data.buffer as ArrayBuffer;\r\n\t}\r\n\r\n\tget length(): number {\r\n\t\treturn this.byteLength / this.BYTES_PER_ELEMENT;\r\n\t}\r\n\r\n\tget(idx: number): string {\r\n\t\tconst view = new Uint8Array(\r\n\t\t\tthis.buffer,\r\n\t\t\tthis.byteOffset + this.chars * idx,\r\n\t\t\tthis.chars,\r\n\t\t);\r\n\t\t// biome-ignore lint/suspicious/noControlCharactersInRegex: necessary for null byte removal\r\n\t\treturn new TextDecoder().decode(view).replace(/\\x00/g, \"\");\r\n\t}\r\n\r\n\tset(idx: number, value: string): void {\r\n\t\tconst view = new Uint8Array(\r\n\t\t\tthis.buffer,\r\n\t\t\tthis.byteOffset + this.chars * idx,\r\n\t\t\tthis.chars,\r\n\t\t);\r\n\t\tview.fill(0); // clear current\r\n\t\tview.set(this.#encoder.encode(value));\r\n\t}\r\n\r\n\tfill(value: string): void {\r\n\t\tconst encoded = this.#encoder.encode(value);\r\n\t\tfor (let i = 0; i < this.length; i++) {\r\n\t\t\tthis._data.set(encoded, i * this.chars);\r\n\t\t}\r\n\t}\r\n\r\n\t*[Symbol.iterator](): IterableIterator<string> {\r\n\t\tfor (let i = 0; i < this.length; i++) {\r\n\t\t\tyield this.get(i);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * An array-like view of a fixed-length Unicode string buffer.\r\n *\r\n * Encoded as UTF-32 code points.\r\n */\r\nexport class UnicodeStringArray {\r\n\t#data: Int32Array;\r\n\tchars: number;\r\n\r\n\tconstructor(chars: number, size: number);\r\n\tconstructor(\r\n\t\tchars: number,\r\n\t\tbuffer: ArrayBuffer,\r\n\t\tbyteOffset?: number,\r\n\t\tlength?: number,\r\n\t);\r\n\tconstructor(chars: number, arr: Iterable<string>);\r\n\tconstructor(\r\n\t\tchars: number,\r\n\t\tx: number | ArrayBuffer | Iterable<string>,\r\n\t\tbyteOffset?: number,\r\n\t\tlength?: number,\r\n\t) {\r\n\t\tthis.chars = chars;\r\n\t\tif (typeof x === \"number\") {\r\n\t\t\tthis.#data = new Int32Array(x * chars);\r\n\t\t} else if (x instanceof ArrayBuffer) {\r\n\t\t\tif (length) length *= chars;\r\n\t\t\tthis.#data = new Int32Array(x, byteOffset, length);\r\n\t\t} else {\r\n\t\t\tconst values = x;\r\n\t\t\tconst d = new UnicodeStringArray(chars, 1);\r\n\t\t\tthis.#data = new Int32Array(\r\n\t\t\t\t(function* () {\r\n\t\t\t\t\tfor (let str of values) {\r\n\t\t\t\t\t\td.set(0, str);\r\n\t\t\t\t\t\tyield* d.#data;\r\n\t\t\t\t\t}\r\n\t\t\t\t})(),\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tget BYTES_PER_ELEMENT(): number {\r\n\t\treturn this.#data.BYTES_PER_ELEMENT * this.chars;\r\n\t}\r\n\r\n\tget byteLength(): number {\r\n\t\treturn this.#data.byteLength;\r\n\t}\r\n\r\n\tget byteOffset(): number {\r\n\t\treturn this.#data.byteOffset;\r\n\t}\r\n\r\n\tget buffer(): ArrayBuffer {\r\n\t\treturn this.#data.buffer as ArrayBuffer;\r\n\t}\r\n\r\n\tget length(): number {\r\n\t\treturn this.#data.length / this.chars;\r\n\t}\r\n\r\n\tget(idx: number): string {\r\n\t\tconst offset = this.chars * idx;\r\n\t\tlet result = \"\";\r\n\t\tfor (let i = 0; i < this.chars; i++) {\r\n\t\t\tresult += String.fromCodePoint(this.#data[offset + i]);\r\n\t\t}\r\n\t\t// biome-ignore lint/suspicious/noControlCharactersInRegex: necessary for null byte removal\r\n\t\treturn result.replace(/\\u0000/g, \"\");\r\n\t}\r\n\r\n\tset(idx: number, value: string): void {\r\n\t\tconst offset = this.chars * idx;\r\n\t\tconst view = this.#data.subarray(offset, offset + this.chars);\r\n\t\tview.fill(0); // clear current\r\n\t\tfor (let i = 0; i < this.chars; i++) {\r\n\t\t\tview[i] = value.codePointAt(i) ?? 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfill(value: string): void {\r\n\t\t// encode once\r\n\t\tthis.set(0, value);\r\n\t\t// copy the encoded values to all other elements\r\n\t\tlet encoded = this.#data.subarray(0, this.chars);\r\n\t\tfor (let i = 1; i < this.length; i++) {\r\n\t\t\tthis.#data.set(encoded, i * this.chars);\r\n\t\t}\r\n\t}\r\n\r\n\t*[Symbol.iterator](): IterableIterator<string> {\r\n\t\tfor (let i = 0; i < this.length; i++) {\r\n\t\t\tyield this.get(i);\r\n\t\t}\r\n\t}\r\n}\r\n", "import type {\r\n\tArrayMetadata,\r\n\tArrayMetadataV2,\r\n\tBigintDataType,\r\n\tCodecMetadata,\r\n\tDataType,\r\n\tGroupMetadata,\r\n\tNumberDataType,\r\n\tObjectType,\r\n\tScalar,\r\n\tStringDataType,\r\n\tTypedArrayConstructor,\r\n} from \"./metadata.js\";\r\nimport {\r\n\tBoolArray,\r\n\tByteStringArray,\r\n\tUnicodeStringArray,\r\n} from \"./typedarray.js\";\r\n\r\nexport function json_encode_object(o: Record<string, unknown>): Uint8Array {\r\n\tconst str = JSON.stringify(o, null, 2);\r\n\treturn new TextEncoder().encode(str);\r\n}\r\n\r\nexport function json_decode_object(bytes: Uint8Array) {\r\n\tconst str = new TextDecoder().decode(bytes);\r\n\treturn JSON.parse(str);\r\n}\r\n\r\nexport function byteswap_inplace(view: Uint8Array, bytes_per_element: number) {\r\n\tconst numFlips = bytes_per_element / 2;\r\n\tconst endByteIndex = bytes_per_element - 1;\r\n\tlet t = 0;\r\n\tfor (let i = 0; i < view.length; i += bytes_per_element) {\r\n\t\tfor (let j = 0; j < numFlips; j += 1) {\r\n\t\t\tt = view[i + j];\r\n\t\t\tview[i + j] = view[i + endByteIndex - j];\r\n\t\t\tview[i + endByteIndex - j] = t;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function get_ctr<D extends DataType>(\r\n\tdata_type: D,\r\n): TypedArrayConstructor<D> {\r\n\tif (data_type === \"v2:object\") {\r\n\t\treturn globalThis.Array as unknown as TypedArrayConstructor<D>;\r\n\t}\r\n\tlet match = data_type.match(/v2:([US])(\\d+)/);\r\n\tif (match) {\r\n\t\tlet [, kind, chars] = match;\r\n\t\t// @ts-expect-error\r\n\t\treturn (kind === \"U\" ? UnicodeStringArray : ByteStringArray).bind(\r\n\t\t\tnull,\r\n\t\t\tNumber(chars),\r\n\t\t);\r\n\t}\r\n\t// @ts-expect-error - We've checked that the key exists\r\n\tlet ctr: TypedArrayConstructor<D> | undefined = (\r\n\t\t{\r\n\t\t\tint8: Int8Array,\r\n\t\t\tint16: Int16Array,\r\n\t\t\tint32: Int32Array,\r\n\t\t\tint64: globalThis.BigInt64Array,\r\n\t\t\tuint8: Uint8Array,\r\n\t\t\tuint16: Uint16Array,\r\n\t\t\tuint32: Uint32Array,\r\n\t\t\tuint64: globalThis.BigUint64Array,\r\n\t\t\tfloat16: globalThis.Float16Array,\r\n\t\t\tfloat32: Float32Array,\r\n\t\t\tfloat64: Float64Array,\r\n\t\t\tbool: BoolArray,\r\n\t\t} as const\r\n\t)[data_type];\r\n\tassert(ctr, `Unknown or unsupported data_type: ${data_type}`);\r\n\treturn ctr;\r\n}\r\n\r\n/** Compute strides for 'C' or 'F' ordered array from shape */\r\nexport function get_strides(\r\n\tshape: readonly number[],\r\n\torder: \"C\" | \"F\" | Array<number>,\r\n): Array<number> {\r\n\tconst rank = shape.length;\r\n\tif (typeof order === \"string\") {\r\n\t\torder =\r\n\t\t\torder === \"C\"\r\n\t\t\t\t? Array.from({ length: rank }, (_, i) => i) // Row-major (identity order)\r\n\t\t\t\t: Array.from({ length: rank }, (_, i) => rank - 1 - i); // Column-major (reverse order)\r\n\t}\r\n\tassert(\r\n\t\trank === order.length,\r\n\t\t\"Order length must match the number of dimensions.\",\r\n\t);\r\n\r\n\tlet step = 1;\r\n\tlet stride = new Array(rank);\r\n\tfor (let i = order.length - 1; i >= 0; i--) {\r\n\t\tstride[order[i]] = step;\r\n\t\tstep *= shape[order[i]];\r\n\t}\r\n\r\n\treturn stride;\r\n}\r\n\r\n// https://zarr-specs.readthedocs.io/en/latest/v3/core/v3.0.html#chunk-key-encoding\r\nexport function create_chunk_key_encoder({\r\n\tname,\r\n\tconfiguration,\r\n}: ArrayMetadata[\"chunk_key_encoding\"]): (chunk_coords: number[]) => string {\r\n\tif (name === \"default\") {\r\n\t\tconst separator = configuration?.separator ?? \"/\";\r\n\t\treturn (chunk_coords) => [\"c\", ...chunk_coords].join(separator);\r\n\t}\r\n\tif (name === \"v2\") {\r\n\t\tconst separator = configuration?.separator ?? \".\";\r\n\t\treturn (chunk_coords) => chunk_coords.join(separator) || \"0\";\r\n\t}\r\n\tthrow new Error(`Unknown chunk key encoding: ${name}`);\r\n}\r\n\r\nfunction coerce_dtype(\r\n\tdtype: string,\r\n): { data_type: DataType } | { data_type: DataType; endian: \"little\" | \"big\" } {\r\n\tif (dtype === \"|O\") {\r\n\t\treturn { data_type: \"v2:object\" };\r\n\t}\r\n\r\n\tlet match = dtype.match(/^([<|>])(.*)$/);\r\n\tassert(match, `Invalid dtype: ${dtype}`);\r\n\r\n\tlet [, endian, rest] = match;\r\n\tlet data_type =\r\n\t\t{\r\n\t\t\tb1: \"bool\",\r\n\t\t\ti1: \"int8\",\r\n\t\t\tu1: \"uint8\",\r\n\t\t\ti2: \"int16\",\r\n\t\t\tu2: \"uint16\",\r\n\t\t\ti4: \"int32\",\r\n\t\t\tu4: \"uint32\",\r\n\t\t\ti8: \"int64\",\r\n\t\t\tu8: \"uint64\",\r\n\t\t\tf2: \"float16\",\r\n\t\t\tf4: \"float32\",\r\n\t\t\tf8: \"float64\",\r\n\t\t}[rest] ??\r\n\t\t(rest.startsWith(\"S\") || rest.startsWith(\"U\") ? `v2:${rest}` : undefined);\r\n\tassert(data_type, `Unsupported or unknown dtype: ${dtype}`);\r\n\tif (endian === \"|\") {\r\n\t\treturn { data_type } as { data_type: DataType };\r\n\t}\r\n\treturn { data_type, endian: endian === \"<\" ? \"little\" : \"big\" } as {\r\n\t\tdata_type: DataType;\r\n\t\tendian: \"little\" | \"big\";\r\n\t};\r\n}\r\n\r\nexport function v2_to_v3_array_metadata(\r\n\tmeta: ArrayMetadataV2,\r\n\tattributes: Record<string, unknown> = {},\r\n): ArrayMetadata<DataType> {\r\n\tlet codecs: CodecMetadata[] = [];\r\n\tlet dtype = coerce_dtype(meta.dtype);\r\n\tif (meta.order === \"F\") {\r\n\t\tcodecs.push({ name: \"transpose\", configuration: { order: \"F\" } });\r\n\t}\r\n\tif (\"endian\" in dtype && dtype.endian === \"big\") {\r\n\t\tcodecs.push({ name: \"bytes\", configuration: { endian: \"big\" } });\r\n\t}\r\n\tfor (let { id, ...configuration } of meta.filters ?? []) {\r\n\t\tcodecs.push({ name: id, configuration });\r\n\t}\r\n\tif (meta.compressor) {\r\n\t\tlet { id, ...configuration } = meta.compressor;\r\n\t\tcodecs.push({ name: id, configuration });\r\n\t}\r\n\treturn {\r\n\t\tzarr_format: 3,\r\n\t\tnode_type: \"array\",\r\n\t\tshape: meta.shape,\r\n\t\tdata_type: dtype.data_type,\r\n\t\tchunk_grid: {\r\n\t\t\tname: \"regular\",\r\n\t\t\tconfiguration: {\r\n\t\t\t\tchunk_shape: meta.chunks,\r\n\t\t\t},\r\n\t\t},\r\n\t\tchunk_key_encoding: {\r\n\t\t\tname: \"v2\",\r\n\t\t\tconfiguration: {\r\n\t\t\t\tseparator: meta.dimension_separator ?? \".\",\r\n\t\t\t},\r\n\t\t},\r\n\t\tcodecs,\r\n\t\tfill_value: meta.fill_value,\r\n\t\tattributes,\r\n\t};\r\n}\r\n\r\nexport function v2_to_v3_group_metadata(\r\n\t_meta: unknown,\r\n\tattributes: Record<string, unknown> = {},\r\n): GroupMetadata {\r\n\treturn {\r\n\t\tzarr_format: 3,\r\n\t\tnode_type: \"group\",\r\n\t\tattributes,\r\n\t};\r\n}\r\n\r\nexport type DataTypeQuery =\r\n\t| DataType\r\n\t| \"boolean\"\r\n\t| \"number\"\r\n\t| \"bigint\"\r\n\t| \"object\"\r\n\t| \"string\";\r\n\r\nexport type NarrowDataType<\r\n\tDtype extends DataType,\r\n\tQuery extends DataTypeQuery,\r\n> = Query extends \"number\"\r\n\t? NumberDataType\r\n\t: Query extends \"bigint\"\r\n\t\t? BigintDataType\r\n\t\t: Query extends \"string\"\r\n\t\t\t? StringDataType\r\n\t\t\t: Query extends \"object\"\r\n\t\t\t\t? ObjectType\r\n\t\t\t\t: Extract<Query, Dtype>;\r\n\r\nexport function is_dtype<Query extends DataTypeQuery>(\r\n\tdtype: DataType,\r\n\tquery: Query,\r\n): dtype is NarrowDataType<DataType, Query> {\r\n\tif (\r\n\t\tquery !== \"number\" &&\r\n\t\tquery !== \"bigint\" &&\r\n\t\tquery !== \"boolean\" &&\r\n\t\tquery !== \"object\" &&\r\n\t\tquery !== \"string\"\r\n\t) {\r\n\t\treturn dtype === query;\r\n\t}\r\n\tlet is_boolean = dtype === \"bool\";\r\n\tif (query === \"boolean\") return is_boolean;\r\n\tlet is_string = dtype.startsWith(\"v2:U\") || dtype.startsWith(\"v2:S\");\r\n\tif (query === \"string\") return is_string;\r\n\tlet is_bigint = dtype === \"int64\" || dtype === \"uint64\";\r\n\tif (query === \"bigint\") return is_bigint;\r\n\tlet is_object = dtype === \"v2:object\";\r\n\tif (query === \"object\") return is_object;\r\n\treturn !is_string && !is_bigint && !is_boolean && !is_object;\r\n}\r\n\r\nexport type ShardingCodecMetadata = {\r\n\tname: \"sharding_indexed\";\r\n\tconfiguration: {\r\n\t\tchunk_shape: number[];\r\n\t\tcodecs: CodecMetadata[];\r\n\t\tindex_codecs: CodecMetadata[];\r\n\t};\r\n};\r\n\r\nexport function is_sharding_codec(\r\n\tcodec: CodecMetadata,\r\n): codec is ShardingCodecMetadata {\r\n\treturn codec?.name === \"sharding_indexed\";\r\n}\r\n\r\nexport function ensure_correct_scalar<D extends DataType>(\r\n\tmetadata: ArrayMetadata<D>,\r\n): Scalar<D> | null {\r\n\tif (\r\n\t\t(metadata.data_type === \"uint64\" || metadata.data_type === \"int64\") &&\r\n\t\tmetadata.fill_value != null\r\n\t) {\r\n\t\t// @ts-expect-error - We've narrowed the type of fill_value correctly\r\n\t\treturn BigInt(metadata.fill_value) as Scalar<D>;\r\n\t}\r\n\treturn metadata.fill_value;\r\n}\r\n\r\n// biome-ignore lint/suspicious/noExplicitAny: Necessary for type inference\r\ntype InstanceType<T> = T extends new (...args: any[]) => infer R ? R : never;\r\n\r\n// biome-ignore lint/suspicious/noExplicitAny: Abstract base type\r\ntype ErrorConstructor = new (...args: any[]) => Error;\r\n\r\n/**\r\n * Ensures an error matches expected type(s), otherwise rethrows.\r\n *\r\n * Unmatched errors bubble up, like Python's `except`. Narrows error types for\r\n * type-safe property access.\r\n *\r\n * @see {@link https://gist.github.com/manzt/3702f19abb714e21c22ce48851c75abf}\r\n *\r\n * @example\r\n * ```ts\r\n * class DatabaseError extends Error { }\r\n * class NetworkError extends Error { }\r\n *\r\n * try {\r\n *   await db.query();\r\n * } catch (err) {\r\n *   rethrow_unless(err, DatabaseError, NetworkError);\r\n *   err // DatabaseError | NetworkError\r\n * }\r\n * ```\r\n *\r\n * @param error - The error to check\r\n * @param errors - Expected error type(s)\r\n * @throws The original error if it doesn't match expected type(s)\r\n */\r\nexport function rethrow_unless<E extends ReadonlyArray<ErrorConstructor>>(\r\n\terror: unknown,\r\n\t...errors: E\r\n): asserts error is InstanceType<E[number]> {\r\n\tif (!errors.some((ErrorClass) => error instanceof ErrorClass)) {\r\n\t\tthrow error;\r\n\t}\r\n}\r\n\r\n/**\r\n * Make an assertion.\r\n *\r\n * Usage\r\n * @example\r\n * ```ts\r\n * const value: boolean = Math.random() <= 0.5;\r\n * assert(value, \"value is greater than than 0.5!\");\r\n * value // true\r\n * ```\r\n *\r\n * @param expression - The expression to test.\r\n * @param msg - The optional message to display if the assertion fails.\r\n * @throws an {@link Error} if `expression` is not truthy.\r\n */\r\nexport function assert(\r\n\texpression: unknown,\r\n\tmsg: string | undefined = \"\",\r\n): asserts expression {\r\n\tif (!expression) {\r\n\t\tthrow new Error(msg);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {ArrayBuffer |ArrayBufferView | Response} data\r\n * @param {Object} options\r\n * @param {CompressionFormat} options.format\r\n * @param {AbortSignal} [options.signal]\r\n *\r\n * @returns {Promise<ArrayBuffer>}\r\n */\r\nexport async function decompress(\r\n\tdata: ArrayBuffer | ArrayBufferView | Response,\r\n\t{ format, signal }: { format: CompressionFormat; signal?: AbortSignal },\r\n): Promise<ArrayBuffer> {\r\n\tconst response = data instanceof Response ? data : new Response(data);\r\n\tassert(response.body, \"Response does not contain body.\");\r\n\ttry {\r\n\t\tconst decompressedResponse = new Response(\r\n\t\t\tresponse.body.pipeThrough(new DecompressionStream(format), { signal }),\r\n\t\t);\r\n\t\tconst buffer = await decompressedResponse.arrayBuffer();\r\n\t\treturn buffer;\r\n\t} catch {\r\n\t\tsignal?.throwIfAborted();\r\n\t\tthrow new Error(`Failed to decode ${format}`);\r\n\t}\r\n}\r\n", "import type { Chunk, Float32, Float64 } from \"../metadata.js\";\r\nimport { assert } from \"../util.js\";\r\n\r\n/**\r\n * A codec for bit-rounding.\r\n *\r\n * Reduces floating-point precision by truncating mantissa bits during encoding.\r\n * Decoding is a no-op as the process is lossy and precision cannot be restored.\r\n *\r\n * Note: {@link BitroundCodec.encode} is not yet implemented since Zarrita is\r\n * primarily used in read-only contexts (web browser). If you need encoding support,\r\n * please open an issue at {@link https://github.com/manzt/zarrita.js/issues}.\r\n *\r\n * @see {@link https://github.com/zarr-developers/numcodecs/blob/main/numcodecs/bitround.py}\r\n * for the original Python implementation.\r\n *\r\n * @remarks\r\n * Data types are not validated, and `float16` arrays are not supported (reflecting browser support).\r\n */\r\nexport class BitroundCodec<D extends Float64 | Float32> {\r\n\tkind = \"array_to_array\";\r\n\r\n\tconstructor(configuration: { keepbits: number }, _meta: { data_type: D }) {\r\n\t\tassert(configuration.keepbits >= 0, \"keepbits must be zero or positive\");\r\n\t}\r\n\r\n\tstatic fromConfig<D extends Float32 | Float64>(\r\n\t\tconfiguration: { keepbits: number },\r\n\t\tmeta: { data_type: D },\r\n\t): BitroundCodec<D> {\r\n\t\treturn new BitroundCodec(configuration, meta);\r\n\t}\r\n\r\n\t/**\r\n\t * Encode a chunk of data with bit-rounding.\r\n\t * @param _arr - The chunk to encode\r\n\t */\r\n\tencode(_arr: Chunk<D>): Chunk<D> {\r\n\t\tthrow new Error(\r\n\t\t\t\"`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.\",\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Decode a chunk of data (no-op).\r\n\t * @param arr - The chunk to decode\r\n\t * @returns The decoded chunk\r\n\t */\r\n\tdecode(arr: Chunk<D>): Chunk<D> {\r\n\t\treturn arr; // No-op as bit-rounding is lossy\r\n\t}\r\n}\r\n", "import type {\r\n\tChunk,\r\n\tCodecMetadata,\r\n\tDataType,\r\n\tTypedArrayConstructor,\r\n} from \"../metadata.js\";\r\nimport { byteswap_inplace, get_ctr, get_strides } from \"../util.js\";\r\n\r\nconst LITTLE_ENDIAN_OS = system_is_little_endian();\r\n\r\nfunction system_is_little_endian(): boolean {\r\n\tconst a = new Uint32Array([0x12345678]);\r\n\tconst b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\r\n\treturn !(b[0] === 0x12);\r\n}\r\n\r\nfunction bytes_per_element<D extends DataType>(\r\n\tTypedArray: TypedArrayConstructor<D>,\r\n): number {\r\n\tif (\"BYTES_PER_ELEMENT\" in TypedArray) {\r\n\t\treturn TypedArray.BYTES_PER_ELEMENT as number;\r\n\t}\r\n\t// Unicode string array is backed by a Int32Array.\r\n\treturn 4;\r\n}\r\n\r\nexport class BytesCodec<D extends Exclude<DataType, \"v2:object\">> {\r\n\tkind = \"array_to_bytes\";\r\n\t#stride: Array<number>;\r\n\t#TypedArray: TypedArrayConstructor<D>;\r\n\t#BYTES_PER_ELEMENT: number;\r\n\t#shape: Array<number>;\r\n\t#endian?: \"little\" | \"big\";\r\n\r\n\tconstructor(\r\n\t\tconfiguration: { endian?: \"little\" | \"big\" } | undefined,\r\n\t\tmeta: { data_type: D; shape: number[]; codecs: CodecMetadata[] },\r\n\t) {\r\n\t\tthis.#endian = configuration?.endian;\r\n\t\tthis.#TypedArray = get_ctr(meta.data_type);\r\n\t\tthis.#shape = meta.shape;\r\n\t\tthis.#stride = get_strides(meta.shape, \"C\");\r\n\t\t// TODO: fix me.\r\n\t\t// hack to get bytes per element since it's dynamic for string types.\r\n\t\tconst sample = new this.#TypedArray(0);\r\n\t\tthis.#BYTES_PER_ELEMENT = sample.BYTES_PER_ELEMENT;\r\n\t}\r\n\r\n\tstatic fromConfig<D extends Exclude<DataType, \"v2:object\">>(\r\n\t\tconfiguration: { endian: \"little\" | \"big\" },\r\n\t\tmeta: { data_type: D; shape: number[]; codecs: CodecMetadata[] },\r\n\t): BytesCodec<D> {\r\n\t\treturn new BytesCodec(configuration, meta);\r\n\t}\r\n\r\n\tencode(arr: Chunk<D>): Uint8Array {\r\n\t\tlet bytes = new Uint8Array(arr.data.buffer);\r\n\t\tif (LITTLE_ENDIAN_OS && this.#endian === \"big\") {\r\n\t\t\tbyteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\r\n\t\t}\r\n\t\treturn bytes;\r\n\t}\r\n\r\n\tdecode(bytes: Uint8Array): Chunk<D> {\r\n\t\tif (LITTLE_ENDIAN_OS && this.#endian === \"big\") {\r\n\t\t\tbyteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\r\n\t\t}\r\n\t\treturn {\r\n\t\t\tdata: new this.#TypedArray(\r\n\t\t\t\tbytes.buffer,\r\n\t\t\t\tbytes.byteOffset,\r\n\t\t\t\tbytes.byteLength / this.#BYTES_PER_ELEMENT,\r\n\t\t\t),\r\n\t\t\tshape: this.#shape,\r\n\t\t\tstride: this.#stride,\r\n\t\t};\r\n\t}\r\n}\r\n", "export class Crc32cCodec {\r\n\treadonly kind = \"bytes_to_bytes\";\r\n\tstatic fromConfig() {\r\n\t\treturn new Crc32cCodec();\r\n\t}\r\n\tencode(_: Uint8Array): Uint8Array {\r\n\t\tthrow new Error(\"Not implemented\");\r\n\t}\r\n\tdecode(arr: Uint8Array): Uint8Array {\r\n\t\treturn new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength - 4);\r\n\t}\r\n}\r\n", "import { decompress } from \"../util.js\";\r\n\r\ninterface GzipCodecConfig {\r\n\tlevel: number;\r\n}\r\n\r\nexport class GzipCodec {\r\n\tkind = \"bytes_to_bytes\";\r\n\r\n\tstatic fromConfig(_: GzipCodecConfig) {\r\n\t\treturn new GzipCodec();\r\n\t}\r\n\r\n\tencode(_bytes: Uint8Array): never {\r\n\t\tthrow new Error(\r\n\t\t\t\"Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.\",\r\n\t\t);\r\n\t}\r\n\r\n\tasync decode(bytes: Uint8Array): Promise<Uint8Array> {\r\n\t\tconst buffer = await decompress(bytes, { format: \"gzip\" });\r\n\t\treturn new Uint8Array(buffer);\r\n\t}\r\n}\r\n", "// Adapted from https://github.com/hms-dbmi/vizarr/blob/5b0e3ea6fbb42d19d0e38e60e49bb73d1aca0693/src/utils.ts#L26\r\nimport type { Chunk, ObjectType } from \"../metadata.js\";\r\nimport { assert, get_strides, json_decode_object } from \"../util.js\";\r\n\r\ntype EncoderConfig = {\r\n\tencoding?: \"utf-8\";\r\n\tskipkeys?: boolean;\r\n\tensure_ascii?: boolean;\r\n\tcheck_circular?: boolean;\r\n\tallow_nan?: boolean;\r\n\tsort_keys?: boolean;\r\n\tindent?: number;\r\n\tseparators?: [string, string];\r\n};\r\ntype DecoderConfig = {\r\n\tstrict?: boolean;\r\n};\r\n\r\ntype JsonCodecConfig = EncoderConfig & DecoderConfig;\r\n\r\n// TODO: Correctly type the replacer function\r\n// biome-ignore lint/suspicious/noExplicitAny: Really complex type\r\ntype ReplacerFunction = (key: string | number, value: any) => any;\r\n\r\n// Reference: https://stackoverflow.com/a/21897413\r\nfunction throw_on_nan_replacer(_key: string | number, value: number): number {\r\n\tassert(\r\n\t\t!Number.isNaN(value),\r\n\t\t\"JsonCodec allow_nan is false but NaN was encountered during encoding.\",\r\n\t);\r\n\tassert(\r\n\t\tvalue !== Number.POSITIVE_INFINITY,\r\n\t\t\"JsonCodec allow_nan is false but Infinity was encountered during encoding.\",\r\n\t);\r\n\tassert(\r\n\t\tvalue !== Number.NEGATIVE_INFINITY,\r\n\t\t\"JsonCodec allow_nan is false but -Infinity was encountered during encoding.\",\r\n\t);\r\n\treturn value;\r\n}\r\n\r\n// Reference: https://gist.github.com/davidfurlong/463a83a33b70a3b6618e97ec9679e490\r\nfunction sort_keys_replacer(\r\n\t_key: string | number,\r\n\tvalue: Record<string, unknown>,\r\n) {\r\n\treturn value instanceof Object && !Array.isArray(value)\r\n\t\t? Object.keys(value)\r\n\t\t\t\t.sort()\r\n\t\t\t\t.reduce(\r\n\t\t\t\t\t(sorted, key: string | number) => {\r\n\t\t\t\t\t\tsorted[key] = value[key];\r\n\t\t\t\t\t\treturn sorted;\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{} as Record<string, unknown>,\r\n\t\t\t\t)\r\n\t\t: value;\r\n}\r\n\r\nexport class JsonCodec {\r\n\tkind = \"array_to_bytes\";\r\n\r\n\t#encoder_config: EncoderConfig;\r\n\t#decoder_config: DecoderConfig;\r\n\r\n\tconstructor(public configuration: JsonCodecConfig = {}) {\r\n\t\t// Reference: https://github.com/zarr-developers/numcodecs/blob/0878717a3613d91a453fe3d3716aa9c67c023a8b/numcodecs/json.py#L36\r\n\t\tconst {\r\n\t\t\tencoding = \"utf-8\",\r\n\t\t\tskipkeys = false,\r\n\t\t\tensure_ascii = true,\r\n\t\t\tcheck_circular = true,\r\n\t\t\tallow_nan = true,\r\n\t\t\tsort_keys = true,\r\n\t\t\tindent,\r\n\t\t\tstrict = true,\r\n\t\t} = configuration;\r\n\r\n\t\tlet separators = configuration.separators;\r\n\t\tif (!separators) {\r\n\t\t\t// ensure separators are explicitly specified, and consistent behaviour across\r\n\t\t\t// Python versions, and most compact representation if indent is None\r\n\t\t\tif (!indent) {\r\n\t\t\t\tseparators = [\",\", \":\"];\r\n\t\t\t} else {\r\n\t\t\t\tseparators = [\", \", \": \"];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.#encoder_config = {\r\n\t\t\tencoding,\r\n\t\t\tskipkeys,\r\n\t\t\tensure_ascii,\r\n\t\t\tcheck_circular,\r\n\t\t\tallow_nan,\r\n\t\t\tindent,\r\n\t\t\tseparators,\r\n\t\t\tsort_keys,\r\n\t\t};\r\n\t\tthis.#decoder_config = { strict };\r\n\t}\r\n\tstatic fromConfig(configuration: JsonCodecConfig) {\r\n\t\treturn new JsonCodec(configuration);\r\n\t}\r\n\r\n\tencode(buf: Chunk<ObjectType>): Uint8Array {\r\n\t\tconst {\r\n\t\t\tindent,\r\n\t\t\tencoding,\r\n\t\t\tensure_ascii,\r\n\t\t\tcheck_circular,\r\n\t\t\tallow_nan,\r\n\t\t\tsort_keys,\r\n\t\t} = this.#encoder_config;\r\n\t\tassert(\r\n\t\t\tencoding === \"utf-8\",\r\n\t\t\t\"JsonCodec does not yet support non-utf-8 encoding.\",\r\n\t\t);\r\n\t\tconst replacer_functions: ReplacerFunction[] = [];\r\n\r\n\t\t// By default, for JSON.stringify,\r\n\t\t// a TypeError will be thrown if one attempts to encode an object with circular references\r\n\t\tassert(\r\n\t\t\tcheck_circular,\r\n\t\t\t\"JsonCodec does not yet support skipping the check for circular references during encoding.\",\r\n\t\t);\r\n\r\n\t\tif (!allow_nan) {\r\n\t\t\t// Throw if NaN/Infinity/-Infinity are encountered during encoding.\r\n\t\t\treplacer_functions.push(throw_on_nan_replacer);\r\n\t\t}\r\n\t\tif (sort_keys) {\r\n\t\t\t// We can ensure keys are sorted but not really the opposite since\r\n\t\t\t// there is no guarantee of key ordering in JS.\r\n\t\t\treplacer_functions.push(sort_keys_replacer);\r\n\t\t}\r\n\r\n\t\tconst items = Array.from(buf.data);\r\n\t\titems.push(\"|O\");\r\n\t\titems.push(buf.shape);\r\n\r\n\t\tlet replacer: ReplacerFunction | undefined;\r\n\t\tif (replacer_functions.length) {\r\n\t\t\treplacer = (key, value) => {\r\n\t\t\t\tlet new_value = value;\r\n\t\t\t\tfor (let sub_replacer of replacer_functions) {\r\n\t\t\t\t\tnew_value = sub_replacer(key, new_value);\r\n\t\t\t\t}\r\n\t\t\t\treturn new_value;\r\n\t\t\t};\r\n\t\t}\r\n\t\tlet json_str = JSON.stringify(items, replacer, indent);\r\n\r\n\t\tif (ensure_ascii) {\r\n\t\t\t// If ensure_ascii is true (the default), the output is guaranteed\r\n\t\t\t// to have all incoming non-ASCII characters escaped.\r\n\t\t\t// If ensure_ascii is false, these characters will be output as-is.\r\n\t\t\t// Reference: https://stackoverflow.com/a/31652607\r\n\t\t\tjson_str = json_str.replace(/[\\u007F-\\uFFFF]/g, (chr) => {\r\n\t\t\t\tconst full_str = `0000${chr.charCodeAt(0).toString(16)}`;\r\n\t\t\t\tconst sub_str = full_str.substring(full_str.length - 4);\r\n\t\t\t\treturn `\\\\u${sub_str}`;\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn new TextEncoder().encode(json_str);\r\n\t}\r\n\r\n\tdecode(bytes: Uint8Array): Chunk<ObjectType> {\r\n\t\tconst { strict } = this.#decoder_config;\r\n\t\t// (i.e., allowing control characters inside strings)\r\n\t\tassert(strict, \"JsonCodec does not yet support non-strict decoding.\");\r\n\r\n\t\tconst items = json_decode_object(bytes);\r\n\t\tconst shape = items.pop();\r\n\t\titems.pop(); // Pop off dtype (unused)\r\n\r\n\t\t// O-d case\r\n\t\tassert(shape, \"0D not implemented for JsonCodec.\");\r\n\t\tconst stride = get_strides(shape, \"C\");\r\n\t\tconst data = items;\r\n\t\treturn { data, shape, stride };\r\n\t}\r\n}\r\n", "import type {\r\n\tChunk,\r\n\tDataType,\r\n\tScalar,\r\n\tTypedArray,\r\n\tTypedArrayConstructor,\r\n} from \"../metadata.js\";\r\nimport {\r\n\tBoolArray,\r\n\tByteStringArray,\r\n\tUnicodeStringArray,\r\n} from \"../typedarray.js\";\r\nimport { assert, get_strides } from \"../util.js\";\r\n\r\ntype TypedArrayProxy<D extends DataType> = {\r\n\t[x: number]: Scalar<D>;\r\n};\r\n\r\nfunction proxy<D extends DataType>(arr: TypedArray<D>): TypedArrayProxy<D> {\r\n\tif (\r\n\t\tarr instanceof BoolArray ||\r\n\t\tarr instanceof ByteStringArray ||\r\n\t\tarr instanceof UnicodeStringArray\r\n\t) {\r\n\t\t// @ts-expect-error - TS cannot infer arr is a TypedArrayProxy<D>\r\n\t\tconst arrp: TypedArrayProxy<D> = new Proxy(arr, {\r\n\t\t\tget(target, prop) {\r\n\t\t\t\treturn target.get(Number(prop));\r\n\t\t\t},\r\n\t\t\tset(target, prop, value) {\r\n\t\t\t\t// @ts-expect-error - value is OK\r\n\t\t\t\ttarget.set(Number(prop), value);\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t});\r\n\t\treturn arrp;\r\n\t}\r\n\t// @ts-expect-error - TS cannot infer arr is a TypedArrayProxy<D>\r\n\treturn arr;\r\n}\r\n\r\nfunction empty_like<D extends DataType>(\r\n\tchunk: Chunk<D>,\r\n\torder: Order,\r\n): Chunk<D> {\r\n\tlet data: TypedArray<D>;\r\n\tif (\r\n\t\tchunk.data instanceof ByteStringArray ||\r\n\t\tchunk.data instanceof UnicodeStringArray\r\n\t) {\r\n\t\tdata = new (chunk.constructor as TypedArrayConstructor<D>)(\r\n\t\t\t// @ts-expect-error\r\n\t\t\tchunk.data.length,\r\n\t\t\tchunk.data.chars,\r\n\t\t);\r\n\t} else {\r\n\t\tdata = new (chunk.constructor as TypedArrayConstructor<D>)(\r\n\t\t\tchunk.data.length,\r\n\t\t);\r\n\t}\r\n\treturn {\r\n\t\tdata,\r\n\t\tshape: chunk.shape,\r\n\t\tstride: get_strides(chunk.shape, order),\r\n\t};\r\n}\r\n\r\nfunction convert_array_order<D extends DataType>(\r\n\tsrc: Chunk<D>,\r\n\ttarget: Order,\r\n): Chunk<D> {\r\n\tlet out = empty_like(src, target);\r\n\tlet n_dims = src.shape.length;\r\n\tlet size = src.data.length;\r\n\tlet index = Array(n_dims).fill(0);\r\n\r\n\tlet src_data = proxy(src.data);\r\n\tlet out_data = proxy(out.data);\r\n\r\n\tfor (let src_idx = 0; src_idx < size; src_idx++) {\r\n\t\tlet out_idx = 0;\r\n\t\tfor (let dim = 0; dim < n_dims; dim++) {\r\n\t\t\tout_idx += index[dim] * out.stride[dim];\r\n\t\t}\r\n\t\tout_data[out_idx] = src_data[src_idx];\r\n\r\n\t\tindex[0] += 1;\r\n\t\tfor (let dim = 0; dim < n_dims; dim++) {\r\n\t\t\tif (index[dim] === src.shape[dim]) {\r\n\t\t\t\tif (dim + 1 === n_dims) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tindex[dim] = 0;\r\n\t\t\t\tindex[dim + 1] += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn out;\r\n}\r\n\r\n/** Determine the memory order (axis permutation) for a chunk */\r\nfunction get_order(chunk: Chunk<DataType>): number[] {\r\n\tlet rank = chunk.shape.length;\r\n\tassert(\r\n\t\trank === chunk.stride.length,\r\n\t\t\"Shape and stride must have the same length.\",\r\n\t);\r\n\treturn chunk.stride\r\n\t\t.map((s, i) => ({ stride: s, index: i }))\r\n\t\t.sort((a, b) => b.stride - a.stride)\r\n\t\t.map((entry) => entry.index);\r\n}\r\n\r\nfunction matches_order(chunk: Chunk<DataType>, target: Order) {\r\n\tlet source = get_order(chunk);\r\n\tassert(source.length === target.length, \"Orders must match\");\r\n\treturn source.every((dim, i) => dim === target[i]);\r\n}\r\n\r\ntype Order = \"C\" | \"F\" | Array<number>;\r\n\r\nexport class TransposeCodec {\r\n\tkind = \"array_to_array\";\r\n\t#order: Array<number>;\r\n\t#inverseOrder: Array<number>;\r\n\r\n\tconstructor(configuration: { order?: Order }, meta: { shape: number[] }) {\r\n\t\tlet value = configuration.order ?? \"C\";\r\n\t\tlet rank = meta.shape.length;\r\n\t\tlet order = new Array<number>(rank);\r\n\t\tlet inverseOrder = new Array<number>(rank);\r\n\r\n\t\tif (value === \"C\") {\r\n\t\t\tfor (let i = 0; i < rank; ++i) {\r\n\t\t\t\torder[i] = i;\r\n\t\t\t\tinverseOrder[i] = i;\r\n\t\t\t}\r\n\t\t} else if (value === \"F\") {\r\n\t\t\tfor (let i = 0; i < rank; ++i) {\r\n\t\t\t\torder[i] = rank - i - 1;\r\n\t\t\t\tinverseOrder[i] = rank - i - 1;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\torder = value;\r\n\t\t\torder.forEach((x, i) => {\r\n\t\t\t\tassert(\r\n\t\t\t\t\tinverseOrder[x] === undefined,\r\n\t\t\t\t\t`Invalid permutation: ${JSON.stringify(value)}`,\r\n\t\t\t\t);\r\n\t\t\t\tinverseOrder[x] = i;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.#order = order;\r\n\t\tthis.#inverseOrder = inverseOrder;\r\n\t}\r\n\r\n\tstatic fromConfig(\r\n\t\tconfiguration: { order: Order },\r\n\t\tmeta: { shape: number[] },\r\n\t) {\r\n\t\treturn new TransposeCodec(configuration, meta);\r\n\t}\r\n\r\n\tencode<D extends DataType>(arr: Chunk<D>): Chunk<D> {\r\n\t\tif (matches_order(arr, this.#inverseOrder)) {\r\n\t\t\t// can skip making a copy\r\n\t\t\treturn arr;\r\n\t\t}\r\n\t\treturn convert_array_order(arr, this.#inverseOrder);\r\n\t}\r\n\r\n\tdecode<D extends DataType>(arr: Chunk<D>): Chunk<D> {\r\n\t\treturn {\r\n\t\t\tdata: arr.data,\r\n\t\t\tshape: arr.shape,\r\n\t\t\tstride: get_strides(arr.shape, this.#order),\r\n\t\t};\r\n\t}\r\n}\r\n", "import type { Chunk, ObjectType } from \"../metadata.js\";\r\nimport { get_strides } from \"../util.js\";\r\n\r\nexport class VLenUTF8 {\r\n\treadonly kind = \"array_to_bytes\";\r\n\t#shape: number[];\r\n\t#strides: number[];\r\n\r\n\tconstructor(shape: number[]) {\r\n\t\tthis.#shape = shape;\r\n\t\tthis.#strides = get_strides(shape, \"C\");\r\n\t}\r\n\tstatic fromConfig(_: unknown, meta: { shape: number[] }) {\r\n\t\treturn new VLenUTF8(meta.shape);\r\n\t}\r\n\r\n\tencode(_chunk: Chunk<ObjectType>): Uint8Array {\r\n\t\tthrow new Error(\"Method not implemented.\");\r\n\t}\r\n\r\n\tdecode(bytes: Uint8Array): Chunk<ObjectType> {\r\n\t\tlet decoder = new TextDecoder();\r\n\t\tlet view = new DataView(bytes.buffer);\r\n\t\tlet data = Array(view.getUint32(0, true));\r\n\t\tlet pos = 4;\r\n\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\tlet item_length = view.getUint32(pos, true);\r\n\t\t\tpos += 4;\r\n\t\t\tdata[i] = decoder.decode(\r\n\t\t\t\t(bytes.buffer as ArrayBuffer).slice(pos, pos + item_length),\r\n\t\t\t);\r\n\t\t\tpos += item_length;\r\n\t\t}\r\n\t\treturn { data, shape: this.#shape, stride: this.#strides };\r\n\t}\r\n}\r\n", "import { decompress } from \"../util.js\";\r\n\r\ninterface ZlibCodecConfig {\r\n\tlevel: number;\r\n}\r\n\r\nexport class ZlibCodec {\r\n\tkind = \"bytes_to_bytes\";\r\n\r\n\tstatic fromConfig(_: ZlibCodecConfig) {\r\n\t\treturn new ZlibCodec();\r\n\t}\r\n\r\n\tencode(_bytes: Uint8Array): never {\r\n\t\tthrow new Error(\r\n\t\t\t\"Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.\",\r\n\t\t);\r\n\t}\r\n\r\n\tasync decode(bytes: Uint8Array): Promise<Uint8Array> {\r\n\t\tconst buffer = await decompress(bytes, { format: \"deflate\" });\r\n\t\treturn new Uint8Array(buffer);\r\n\t}\r\n}\r\n", "import type { Codec as _Codec } from \"numcodecs\";\r\nimport { BitroundCodec } from \"./codecs/bitround.js\";\r\nimport { BytesCodec } from \"./codecs/bytes.js\";\r\nimport { Crc32cCodec } from \"./codecs/crc32c.js\";\r\nimport { GzipCodec } from \"./codecs/gzip.js\";\r\nimport { JsonCodec } from \"./codecs/json2.js\";\r\nimport { TransposeCodec } from \"./codecs/transpose.js\";\r\nimport { VLenUTF8 } from \"./codecs/vlen-utf8.js\";\r\nimport { ZlibCodec } from \"./codecs/zlib.js\";\r\nimport type { Chunk, CodecMetadata, DataType } from \"./metadata.js\";\r\nimport { assert } from \"./util.js\";\r\n\r\ntype ChunkMetadata<D extends DataType> = {\r\n\tdata_type: D;\r\n\tshape: number[];\r\n\tcodecs: CodecMetadata[];\r\n};\r\n\r\ntype CodecEntry = {\r\n\tfromConfig: (config: unknown, meta: ChunkMetadata<DataType>) => Codec;\r\n\tkind?: \"array_to_array\" | \"array_to_bytes\" | \"bytes_to_bytes\";\r\n};\r\n\r\ntype Codec = _Codec & { kind: CodecEntry[\"kind\"] };\r\n\r\nfunction create_default_registry(): Map<string, () => Promise<CodecEntry>> {\r\n\treturn new Map()\r\n\t\t.set(\"blosc\", () => import(\"numcodecs/blosc\").then((m) => m.default))\r\n\t\t.set(\"lz4\", () => import(\"numcodecs/lz4\").then((m) => m.default))\r\n\t\t.set(\"zstd\", () => import(\"numcodecs/zstd\").then((m) => m.default))\r\n\t\t.set(\"gzip\", () => GzipCodec)\r\n\t\t.set(\"zlib\", () => ZlibCodec)\r\n\t\t.set(\"transpose\", () => TransposeCodec)\r\n\t\t.set(\"bytes\", () => BytesCodec)\r\n\t\t.set(\"crc32c\", () => Crc32cCodec)\r\n\t\t.set(\"vlen-utf8\", () => VLenUTF8)\r\n\t\t.set(\"json2\", () => JsonCodec)\r\n\t\t.set(\"bitround\", () => BitroundCodec);\r\n}\r\n\r\nexport const registry: Map<string, () => Promise<CodecEntry>> =\r\n\tcreate_default_registry();\r\n\r\nexport function create_codec_pipeline<Dtype extends DataType>(\r\n\tchunk_metadata: ChunkMetadata<Dtype>,\r\n): {\r\n\tencode(chunk: Chunk<Dtype>): Promise<Uint8Array>;\r\n\tdecode(bytes: Uint8Array): Promise<Chunk<Dtype>>;\r\n} {\r\n\tlet codecs: Awaited<ReturnType<typeof load_codecs>>;\r\n\treturn {\r\n\t\tasync encode(chunk: Chunk<Dtype>): Promise<Uint8Array> {\r\n\t\t\tif (!codecs) codecs = await load_codecs(chunk_metadata);\r\n\t\t\tfor (const codec of codecs.array_to_array) {\r\n\t\t\t\tchunk = await codec.encode(chunk);\r\n\t\t\t}\r\n\t\t\tlet bytes = await codecs.array_to_bytes.encode(chunk);\r\n\t\t\tfor (const codec of codecs.bytes_to_bytes) {\r\n\t\t\t\tbytes = await codec.encode(bytes);\r\n\t\t\t}\r\n\t\t\treturn bytes;\r\n\t\t},\r\n\t\tasync decode(bytes: Uint8Array): Promise<Chunk<Dtype>> {\r\n\t\t\tif (!codecs) codecs = await load_codecs(chunk_metadata);\r\n\t\t\tfor (let i = codecs.bytes_to_bytes.length - 1; i >= 0; i--) {\r\n\t\t\t\tbytes = await codecs.bytes_to_bytes[i].decode(bytes);\r\n\t\t\t}\r\n\t\t\tlet chunk = await codecs.array_to_bytes.decode(bytes);\r\n\t\t\tfor (let i = codecs.array_to_array.length - 1; i >= 0; i--) {\r\n\t\t\t\tchunk = await codecs.array_to_array[i].decode(chunk);\r\n\t\t\t}\r\n\t\t\treturn chunk;\r\n\t\t},\r\n\t};\r\n}\r\n\r\ntype ArrayToArrayCodec<D extends DataType> = {\r\n\tencode: (data: Chunk<D>) => Promise<Chunk<D>> | Chunk<D>;\r\n\tdecode: (data: Chunk<D>) => Promise<Chunk<D>> | Chunk<D>;\r\n};\r\n\r\ntype ArrayToBytesCodec<D extends DataType> = {\r\n\tencode: (data: Chunk<D>) => Promise<Uint8Array> | Uint8Array;\r\n\tdecode: (data: Uint8Array) => Promise<Chunk<D>> | Chunk<D>;\r\n};\r\n\r\ntype BytesToBytesCodec = {\r\n\tencode: (data: Uint8Array) => Promise<Uint8Array>;\r\n\tdecode: (data: Uint8Array) => Promise<Uint8Array>;\r\n};\r\n\r\nasync function load_codecs<D extends DataType>(chunk_meta: ChunkMetadata<D>) {\r\n\tlet promises = chunk_meta.codecs.map(async (meta) => {\r\n\t\tlet Codec = await registry.get(meta.name)?.();\r\n\t\tassert(Codec, `Unknown codec: ${meta.name}`);\r\n\t\treturn { Codec, meta };\r\n\t});\r\n\tlet array_to_array: ArrayToArrayCodec<D>[] = [];\r\n\tlet array_to_bytes: ArrayToBytesCodec<D> | undefined;\r\n\tlet bytes_to_bytes: BytesToBytesCodec[] = [];\r\n\tfor await (let { Codec, meta } of promises) {\r\n\t\tlet codec = Codec.fromConfig(meta.configuration, chunk_meta);\r\n\t\tswitch (codec.kind) {\r\n\t\t\tcase \"array_to_array\":\r\n\t\t\t\tarray_to_array.push(codec as unknown as ArrayToArrayCodec<D>);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"array_to_bytes\":\r\n\t\t\t\tarray_to_bytes = codec as unknown as ArrayToBytesCodec<D>;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbytes_to_bytes.push(codec as unknown as BytesToBytesCodec);\r\n\t\t}\r\n\t}\r\n\tif (!array_to_bytes) {\r\n\t\tassert(\r\n\t\t\tis_typed_array_like_meta(chunk_meta),\r\n\t\t\t`Cannot encode ${chunk_meta.data_type} to bytes without a codec`,\r\n\t\t);\r\n\t\tarray_to_bytes = BytesCodec.fromConfig({ endian: \"little\" }, chunk_meta);\r\n\t}\r\n\treturn { array_to_array, array_to_bytes, bytes_to_bytes };\r\n}\r\n\r\nfunction is_typed_array_like_meta<D extends DataType>(\r\n\tmeta: ChunkMetadata<D>,\r\n): meta is ChunkMetadata<Exclude<D, \"v2:object\">> {\r\n\treturn meta.data_type !== \"v2:object\";\r\n}\r\n", "export class NodeNotFoundError extends Error {\r\n\tconstructor(context: string, options: { cause?: Error } = {}) {\r\n\t\tsuper(`Node not found: ${context}`, options);\r\n\t\tthis.name = \"NodeNotFoundError\";\r\n\t}\r\n}\r\n\r\nexport class KeyError extends Error {\r\n\tconstructor(path: string) {\r\n\t\tsuper(`Missing key: ${path}`);\r\n\t\tthis.name = \"KeyError\";\r\n\t}\r\n}\r\n", "import type { AbsolutePath, Readable } from \"@zarrita/storage\";\r\nimport { KeyError, NodeNotFoundError } from \"./errors.js\";\r\nimport type {\r\n\tArrayMetadata,\r\n\tArrayMetadataV2,\r\n\tAttributes,\r\n\tGroupMetadata,\r\n\tGroupMetadataV2,\r\n} from \"./metadata.js\";\r\nimport {\r\n\tassert,\r\n\tjson_decode_object,\r\n\tjson_encode_object,\r\n\trethrow_unless,\r\n} from \"./util.js\";\r\n\r\ntype ConsolidatedMetadata = {\r\n\tmetadata: Record<string, ArrayMetadataV2 | GroupMetadataV2>;\r\n\tzarr_consolidated_format: 1;\r\n};\r\n\r\n/**\r\n * Represents a read-only store that can list its contents.\r\n */\r\nexport interface Listable<Store extends Readable> {\r\n\t/** Get the bytes at a given path. */\r\n\tget: (...args: Parameters<Store[\"get\"]>) => Promise<Uint8Array | undefined>;\r\n\t/** Get a byte range at a given path. */\r\n\tgetRange: Store[\"getRange\"];\r\n\t/** List the contents of the store. */\r\n\tcontents(): { path: AbsolutePath; kind: \"array\" | \"group\" }[];\r\n}\r\n\r\nasync function get_consolidated_metadata(\r\n\tstore: Readable,\r\n\tmetadataKeyOption: string | undefined,\r\n): Promise<ConsolidatedMetadata> {\r\n\tconst metadataKey = metadataKeyOption ?? \".zmetadata\";\r\n\tlet bytes = await store.get(`/${metadataKey}`);\r\n\tif (!bytes) {\r\n\t\tthrow new NodeNotFoundError(\"v2 consolidated metadata\", {\r\n\t\t\tcause: new KeyError(`/${metadataKey}`),\r\n\t\t});\r\n\t}\r\n\tlet meta: ConsolidatedMetadata = json_decode_object(bytes);\r\n\tassert(\r\n\t\tmeta.zarr_consolidated_format === 1,\r\n\t\t\"Unsupported consolidated format.\",\r\n\t);\r\n\treturn meta;\r\n}\r\n\r\ntype Metadata =\r\n\t| ArrayMetadataV2\r\n\t| GroupMetadataV2\r\n\t| ArrayMetadata\r\n\t| GroupMetadata\r\n\t| Attributes;\r\n\r\nfunction is_meta_key(key: string): boolean {\r\n\treturn (\r\n\t\tkey.endsWith(\".zarray\") ||\r\n\t\tkey.endsWith(\".zgroup\") ||\r\n\t\tkey.endsWith(\".zattrs\") ||\r\n\t\tkey.endsWith(\"zarr.json\")\r\n\t);\r\n}\r\n\r\nfunction is_v3(meta: Metadata): meta is ArrayMetadata | GroupMetadata {\r\n\treturn \"zarr_format\" in meta && meta.zarr_format === 3;\r\n}\r\n\r\n/** Options for {@linkcode withConsolidated} and {@linkcode tryWithConsolidated}. */\r\nexport interface WithConsolidatedOptions {\r\n\t/**\r\n\t * Key to read consolidated metadata from.\r\n\t *\r\n\t * @default {\".zmetadata\"}\r\n\t */\r\n\treadonly metadataKey?: string;\r\n}\r\n\r\n/**\r\n * Open a consolidated store.\r\n *\r\n * This will open a store with Zarr v2 consolidated metadata (`.zmetadata`).\r\n * @see {@link https://zarr.readthedocs.io/en/stable/spec/v2.html#consolidated-metadata}\r\n *\r\n * @param store The store to open.\r\n * @param opts Options object.\r\n * @returns A listable store.\r\n *\r\n * @example\r\n * ```js\r\n * let store = await withConsolidated(\r\n *   new zarr.FetchStore(\"https://my-bucket.s3.amazonaws.com\");\r\n * );\r\n * store.contents(); // [{ path: \"/\", kind: \"group\" }, { path: \"/foo\", kind: \"array\" }, ...]\r\n * let grp = zarr.open(store); // Open the root group.\r\n * let foo = zarr.open(grp.resolve(contents[1].path)); // Open the foo array\r\n * ```\r\n */\r\nexport async function withConsolidated<Store extends Readable>(\r\n\tstore: Store,\r\n\topts: WithConsolidatedOptions = {},\r\n): Promise<Listable<Store>> {\r\n\tlet v2_meta = await get_consolidated_metadata(store, opts.metadataKey);\r\n\tlet known_meta: Record<AbsolutePath, Metadata> = {};\r\n\tfor (let [key, value] of Object.entries(v2_meta.metadata)) {\r\n\t\tknown_meta[`/${key}`] = value;\r\n\t}\r\n\r\n\treturn {\r\n\t\tasync get(\r\n\t\t\t...args: Parameters<Store[\"get\"]>\r\n\t\t): Promise<Uint8Array | undefined> {\r\n\t\t\tlet [key, opts] = args;\r\n\t\t\tif (known_meta[key]) {\r\n\t\t\t\treturn json_encode_object(known_meta[key]);\r\n\t\t\t}\r\n\t\t\tlet maybe_bytes = await store.get(key, opts);\r\n\t\t\tif (is_meta_key(key) && maybe_bytes) {\r\n\t\t\t\tlet meta = json_decode_object(maybe_bytes);\r\n\t\t\t\tknown_meta[key] = meta;\r\n\t\t\t}\r\n\t\t\treturn maybe_bytes;\r\n\t\t},\r\n\t\t// Delegate range requests to the underlying store.\r\n\t\t// Note: Supporting range requests for consolidated metadata is possible\r\n\t\t// but unlikely to be useful enough to justify the effort.\r\n\t\tgetRange: store.getRange?.bind(store),\r\n\t\tcontents(): { path: AbsolutePath; kind: \"array\" | \"group\" }[] {\r\n\t\t\tlet contents: { path: AbsolutePath; kind: \"array\" | \"group\" }[] = [];\r\n\t\t\tfor (let [key, value] of Object.entries(known_meta)) {\r\n\t\t\t\tlet parts = key.split(\"/\");\r\n\t\t\t\tlet filename = parts.pop();\r\n\t\t\t\tlet path = (parts.join(\"/\") || \"/\") as AbsolutePath;\r\n\t\t\t\tif (filename === \".zarray\") contents.push({ path, kind: \"array\" });\r\n\t\t\t\tif (filename === \".zgroup\") contents.push({ path, kind: \"group\" });\r\n\t\t\t\tif (is_v3(value)) {\r\n\t\t\t\t\tcontents.push({ path, kind: value.node_type });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn contents;\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Try to open a consolidated store, but fall back to the original store if the\r\n * consolidated metadata is missing.\r\n *\r\n * Provides a convenient way to open a store that may or may not have consolidated,\r\n * returning a consistent interface for both cases. Ideal for usage senarios with\r\n * known access paths, since store with consolidated metadata do not incur\r\n * additional network requests when accessing underlying groups and arrays.\r\n *\r\n * @param store The store to open.\r\n * @param opts Options to pass to withConsolidated.\r\n * @returns A listable store.\r\n */\r\nexport async function tryWithConsolidated<Store extends Readable>(\r\n\tstore: Store,\r\n\topts: WithConsolidatedOptions = {},\r\n): Promise<Listable<Store> | Store> {\r\n\treturn withConsolidated(store, opts).catch((error: unknown) => {\r\n\t\trethrow_unless(error, NodeNotFoundError);\r\n\t\treturn store;\r\n\t});\r\n}\r\n", "import type { Readable } from \"@zarrita/storage\";\r\nimport { create_codec_pipeline } from \"../codecs.js\";\r\nimport type { Location } from \"../hierarchy.js\";\r\nimport type { Chunk } from \"../metadata.js\";\r\nimport { assert, type ShardingCodecMetadata } from \"../util.js\";\r\n\r\nconst MAX_BIG_UINT = 18446744073709551615n;\r\n\r\nexport function create_sharded_chunk_getter<Store extends Readable>(\r\n\tlocation: Location<Store>,\r\n\tshard_shape: number[],\r\n\tencode_shard_key: (coord: number[]) => string,\r\n\tsharding_config: ShardingCodecMetadata[\"configuration\"],\r\n) {\r\n\tassert(location.store.getRange, \"Store does not support range requests\");\r\n\tlet get_range = location.store.getRange.bind(location.store);\r\n\tlet index_shape = shard_shape.map(\r\n\t\t(d, i) => d / sharding_config.chunk_shape[i],\r\n\t);\r\n\tlet index_codec = create_codec_pipeline({\r\n\t\tdata_type: \"uint64\",\r\n\t\tshape: [...index_shape, 2],\r\n\t\tcodecs: sharding_config.index_codecs,\r\n\t});\r\n\r\n\tlet cache: Record<string, Chunk<\"uint64\"> | null> = {};\r\n\treturn async (chunk_coord: number[]) => {\r\n\t\tlet shard_coord = chunk_coord.map((d, i) => Math.floor(d / index_shape[i]));\r\n\t\tlet shard_path = location.resolve(encode_shard_key(shard_coord)).path;\r\n\r\n\t\tlet index: Chunk<\"uint64\"> | null;\r\n\t\tif (shard_path in cache) {\r\n\t\t\tindex = cache[shard_path];\r\n\t\t} else {\r\n\t\t\tlet checksum_size = 4;\r\n\t\t\tlet index_size = 16 * index_shape.reduce((a, b) => a * b, 1);\r\n\t\t\tlet bytes = await get_range(shard_path, {\r\n\t\t\t\tsuffixLength: index_size + checksum_size,\r\n\t\t\t});\r\n\t\t\tindex = cache[shard_path] = bytes\r\n\t\t\t\t? await index_codec.decode(bytes)\r\n\t\t\t\t: null;\r\n\t\t}\r\n\r\n\t\tif (index === null) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\tlet { data, shape, stride } = index;\r\n\t\tlet linear_offset = chunk_coord\r\n\t\t\t.map((d, i) => d % shape[i])\r\n\t\t\t.reduce((acc, sel, idx) => acc + sel * stride[idx], 0);\r\n\r\n\t\tlet offset = data[linear_offset];\r\n\t\tlet length = data[linear_offset + 1];\r\n\t\t// write null chunk when 2^64-1 indicates fill value\r\n\t\tif (offset === MAX_BIG_UINT && length === MAX_BIG_UINT) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\treturn get_range(shard_path, {\r\n\t\t\toffset: Number(offset),\r\n\t\t\tlength: Number(length),\r\n\t\t});\r\n\t};\r\n}\r\n", "import type { AbsolutePath, Readable } from \"@zarrita/storage\";\r\nimport { create_sharded_chunk_getter } from \"./codecs/sharding.js\";\r\nimport { create_codec_pipeline } from \"./codecs.js\";\r\nimport type {\r\n\tArrayMetadata,\r\n\tAttributes,\r\n\tChunk,\r\n\tCodecMetadata,\r\n\tDataType,\r\n\tGroupMetadata,\r\n\tScalar,\r\n\tTypedArrayConstructor,\r\n} from \"./metadata.js\";\r\nimport {\r\n\tcreate_chunk_key_encoder,\r\n\ttype DataTypeQuery,\r\n\tensure_correct_scalar,\r\n\tget_ctr,\r\n\tget_strides,\r\n\tis_dtype,\r\n\tis_sharding_codec,\r\n\ttype NarrowDataType,\r\n} from \"./util.js\";\r\n\r\nexport class Location<Store> {\r\n\tconstructor(\r\n\t\tpublic readonly store: Store,\r\n\t\tpublic readonly path: AbsolutePath = \"/\",\r\n\t) {}\r\n\r\n\tresolve(path: string): Location<Store> {\r\n\t\t// reuse URL resolution logic built into the browser\r\n\t\t// handles relative paths, absolute paths, etc.\r\n\t\tlet root = new URL(\r\n\t\t\t`file://${this.path.endsWith(\"/\") ? this.path : `${this.path}/`}`,\r\n\t\t);\r\n\t\treturn new Location(\r\n\t\t\tthis.store,\r\n\t\t\tdecodeURIComponent(new URL(path, root).pathname) as AbsolutePath,\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport function root<Store>(store: Store): Location<Store>;\r\nexport function root(): Location<Map<string, Uint8Array>>;\r\nexport function root<Store>(\r\n\tstore?: Store,\r\n): Location<Store | Map<string, Uint8Array>> {\r\n\treturn new Location(store ?? new Map());\r\n}\r\n\r\nexport class Group<Store extends Readable> extends Location<Store> {\r\n\treadonly kind = \"group\";\r\n\t#metadata: GroupMetadata;\r\n\tconstructor(store: Store, path: AbsolutePath, metadata: GroupMetadata) {\r\n\t\tsuper(store, path);\r\n\t\tthis.#metadata = metadata;\r\n\t}\r\n\tget attrs(): Attributes {\r\n\t\treturn this.#metadata.attributes;\r\n\t}\r\n}\r\n\r\nfunction get_array_order(\r\n\tcodecs: CodecMetadata[],\r\n): \"C\" | \"F\" | globalThis.Array<number> {\r\n\tconst maybe_transpose_codec = codecs.find((c) => c.name === \"transpose\");\r\n\t// @ts-expect-error - TODO: Should validate?\r\n\treturn maybe_transpose_codec?.configuration?.order ?? \"C\";\r\n}\r\n\r\nconst CONTEXT_MARKER = Symbol(\"zarrita.context\");\r\n\r\nexport function get_context<T>(obj: { [CONTEXT_MARKER]: T }): T {\r\n\treturn obj[CONTEXT_MARKER];\r\n}\r\n\r\nfunction create_context<Store extends Readable, D extends DataType>(\r\n\tlocation: Location<Readable>,\r\n\tmetadata: ArrayMetadata<D>,\r\n): ArrayContext<Store, D> {\r\n\tlet { configuration } = metadata.codecs.find(is_sharding_codec) ?? {};\r\n\tlet shared_context = {\r\n\t\tencode_chunk_key: create_chunk_key_encoder(metadata.chunk_key_encoding),\r\n\t\tTypedArray: get_ctr(metadata.data_type),\r\n\t\tfill_value: metadata.fill_value,\r\n\t};\r\n\r\n\tif (configuration) {\r\n\t\tlet native_order = get_array_order(configuration.codecs);\r\n\t\treturn {\r\n\t\t\t...shared_context,\r\n\t\t\tkind: \"sharded\",\r\n\t\t\tchunk_shape: configuration.chunk_shape,\r\n\t\t\tcodec: create_codec_pipeline({\r\n\t\t\t\tdata_type: metadata.data_type,\r\n\t\t\t\tshape: configuration.chunk_shape,\r\n\t\t\t\tcodecs: configuration.codecs,\r\n\t\t\t}),\r\n\t\t\tget_strides(shape: number[]) {\r\n\t\t\t\treturn get_strides(shape, native_order);\r\n\t\t\t},\r\n\t\t\tget_chunk_bytes: create_sharded_chunk_getter(\r\n\t\t\t\tlocation,\r\n\t\t\t\tmetadata.chunk_grid.configuration.chunk_shape,\r\n\t\t\t\tshared_context.encode_chunk_key,\r\n\t\t\t\tconfiguration,\r\n\t\t\t),\r\n\t\t};\r\n\t}\r\n\r\n\tlet native_order = get_array_order(metadata.codecs);\r\n\treturn {\r\n\t\t...shared_context,\r\n\t\tkind: \"regular\",\r\n\t\tchunk_shape: metadata.chunk_grid.configuration.chunk_shape,\r\n\t\tcodec: create_codec_pipeline({\r\n\t\t\tdata_type: metadata.data_type,\r\n\t\t\tshape: metadata.chunk_grid.configuration.chunk_shape,\r\n\t\t\tcodecs: metadata.codecs,\r\n\t\t}),\r\n\t\tget_strides(shape: number[]) {\r\n\t\t\treturn get_strides(shape, native_order);\r\n\t\t},\r\n\t\tasync get_chunk_bytes(chunk_coords, options) {\r\n\t\t\tlet chunk_key = shared_context.encode_chunk_key(chunk_coords);\r\n\t\t\tlet chunk_path = location.resolve(chunk_key).path;\r\n\t\t\treturn location.store.get(chunk_path, options);\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/** For internal use only, and is subject to change. */\r\ninterface ArrayContext<Store extends Readable, D extends DataType> {\r\n\tkind: \"sharded\" | \"regular\";\r\n\t/** The codec pipeline for this array. */\r\n\tcodec: ReturnType<typeof create_codec_pipeline<D>>;\r\n\t/** Encode a chunk key from chunk coordinates. */\r\n\tencode_chunk_key(chunk_coords: number[]): string;\r\n\t/** The TypedArray constructor for this array chunks. */\r\n\tTypedArray: TypedArrayConstructor<D>;\r\n\t/** A function to get the strides for a given shape, using the array order */\r\n\tget_strides(shape: number[]): number[];\r\n\t/** The fill value for this array. */\r\n\tfill_value: Scalar<D> | null;\r\n\t/** A function to get the bytes for a given chunk. */\r\n\tget_chunk_bytes(\r\n\t\tchunk_coords: number[],\r\n\t\toptions?: Parameters<Store[\"get\"]>[1],\r\n\t): Promise<Uint8Array | undefined>;\r\n\t/** The chunk shape for this array. */\r\n\tchunk_shape: number[];\r\n}\r\n\r\nexport class Array<\r\n\tDtype extends DataType,\r\n\tStore extends Readable = Readable,\r\n> extends Location<Store> {\r\n\treadonly kind = \"array\";\r\n\t#metadata: ArrayMetadata<Dtype>;\r\n\t[CONTEXT_MARKER]: ArrayContext<Store, Dtype>;\r\n\r\n\tconstructor(\r\n\t\tstore: Store,\r\n\t\tpath: AbsolutePath,\r\n\t\tmetadata: ArrayMetadata<Dtype>,\r\n\t) {\r\n\t\tsuper(store, path);\r\n\t\tthis.#metadata = {\r\n\t\t\t...metadata,\r\n\t\t\tfill_value: ensure_correct_scalar(metadata),\r\n\t\t};\r\n\t\tthis[CONTEXT_MARKER] = create_context(this, metadata);\r\n\t}\r\n\r\n\tget attrs(): Attributes {\r\n\t\treturn this.#metadata.attributes;\r\n\t}\r\n\r\n\tget shape(): number[] {\r\n\t\treturn this.#metadata.shape;\r\n\t}\r\n\r\n\tget chunks(): number[] {\r\n\t\treturn this[CONTEXT_MARKER].chunk_shape;\r\n\t}\r\n\r\n\tget dtype(): Dtype {\r\n\t\treturn this.#metadata.data_type;\r\n\t}\r\n\r\n\tasync getChunk(\r\n\t\tchunk_coords: number[],\r\n\t\toptions?: Parameters<Store[\"get\"]>[1],\r\n\t): Promise<Chunk<Dtype>> {\r\n\t\tlet context = this[CONTEXT_MARKER];\r\n\t\tlet maybe_bytes = await context.get_chunk_bytes(chunk_coords, options);\r\n\t\tif (!maybe_bytes) {\r\n\t\t\tlet size = context.chunk_shape.reduce((a, b) => a * b, 1);\r\n\t\t\tlet data = new context.TypedArray(size);\r\n\t\t\t// @ts-expect-error: TS can't infer that `fill_value` is union (assumes never) but this is ok\r\n\t\t\tdata.fill(context.fill_value);\r\n\t\t\treturn {\r\n\t\t\t\tdata,\r\n\t\t\t\tshape: context.chunk_shape,\r\n\t\t\t\tstride: context.get_strides(context.chunk_shape),\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn context.codec.decode(maybe_bytes);\r\n\t}\r\n\r\n\t/**\r\n\t * A helper method to narrow `zarr.Array` Dtype.\r\n\t *\r\n\t * ```typescript\r\n\t * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: \"array\" });\r\n\t *\r\n\t * // Option 1: narrow by scalar type (e.g. \"bool\", \"raw\", \"bigint\", \"number\")\r\n\t * if (arr.is(\"bigint\")) {\r\n\t *   // zarr.Array<\"int64\" | \"uint64\", FetchStore>\r\n\t * }\r\n\t *\r\n\t * // Option 3: exact match\r\n\t * if (arr.is(\"float32\")) {\r\n\t *   // zarr.Array<\"float32\", FetchStore, \"/\">\r\n\t * }\r\n\t * ```\r\n\t */\r\n\tis<Query extends DataTypeQuery>(\r\n\t\tquery: Query,\r\n\t): this is Array<NarrowDataType<Dtype, Query>, Store> {\r\n\t\treturn is_dtype(this.dtype, query);\r\n\t}\r\n}\r\n", "import type { Mutable } from \"@zarrita/storage\";\r\n\r\nimport { Array, Group, Location } from \"./hierarchy.js\";\r\nimport type {\r\n\tArrayMetadata,\r\n\tAttributes,\r\n\tCodecMetadata,\r\n\tDataType,\r\n\tGroupMetadata,\r\n\tScalar,\r\n} from \"./metadata.js\";\r\nimport { json_encode_object } from \"./util.js\";\r\n\r\ninterface CreateGroupOptions {\r\n\tattributes?: Record<string, unknown>;\r\n}\r\n\r\ninterface CreateArrayOptions<Dtype extends DataType> {\r\n\tshape: number[];\r\n\tchunk_shape: number[];\r\n\tdata_type: Dtype;\r\n\tcodecs?: CodecMetadata[];\r\n\tfill_value?: Scalar<Dtype>;\r\n\tchunk_separator?: \".\" | \"/\";\r\n\tattributes?: Attributes;\r\n}\r\n\r\nexport async function create<\r\n\tStore extends Mutable,\r\n\t_Dtype extends DataType = DataType,\r\n>(location: Location<Store> | Store): Promise<Group<Store>>;\r\n\r\nexport async function create<\r\n\tStore extends Mutable,\r\n\t_Dtype extends DataType = DataType,\r\n>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: CreateGroupOptions,\r\n): Promise<Group<Store>>;\r\n\r\nexport async function create<Store extends Mutable, Dtype extends DataType>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: CreateArrayOptions<Dtype>,\r\n): Promise<Array<Dtype, Store>>;\r\n\r\nexport async function create<Store extends Mutable, Dtype extends DataType>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: CreateArrayOptions<Dtype> | CreateGroupOptions = {},\r\n): Promise<Array<Dtype, Store> | Group<Store>> {\r\n\tlet loc = \"store\" in location ? location : new Location(location);\r\n\tif (\"shape\" in options) {\r\n\t\tlet arr = await create_array(loc, options);\r\n\t\treturn arr as Array<Dtype, Store>;\r\n\t}\r\n\treturn create_group(loc, options);\r\n}\r\n\r\nasync function create_group<Store extends Mutable>(\r\n\tlocation: Location<Store>,\r\n\toptions: CreateGroupOptions = {},\r\n): Promise<Group<Store>> {\r\n\tlet metadata = {\r\n\t\tzarr_format: 3,\r\n\t\tnode_type: \"group\",\r\n\t\tattributes: options.attributes ?? {},\r\n\t} satisfies GroupMetadata;\r\n\tawait location.store.set(\r\n\t\tlocation.resolve(\"zarr.json\").path,\r\n\t\tjson_encode_object(metadata),\r\n\t);\r\n\treturn new Group(location.store, location.path, metadata);\r\n}\r\n\r\nasync function create_array<Store extends Mutable, Dtype extends DataType>(\r\n\tlocation: Location<Store>,\r\n\toptions: CreateArrayOptions<Dtype>,\r\n): Promise<Array<DataType, Store>> {\r\n\tlet metadata = {\r\n\t\tzarr_format: 3,\r\n\t\tnode_type: \"array\",\r\n\t\tshape: options.shape,\r\n\t\tdata_type: options.data_type,\r\n\t\tchunk_grid: {\r\n\t\t\tname: \"regular\",\r\n\t\t\tconfiguration: {\r\n\t\t\t\tchunk_shape: options.chunk_shape,\r\n\t\t\t},\r\n\t\t},\r\n\t\tchunk_key_encoding: {\r\n\t\t\tname: \"default\",\r\n\t\t\tconfiguration: {\r\n\t\t\t\tseparator: options.chunk_separator ?? \"/\",\r\n\t\t\t},\r\n\t\t},\r\n\t\tcodecs: options.codecs ?? [],\r\n\t\tfill_value: options.fill_value ?? null,\r\n\t\tattributes: options.attributes ?? {},\r\n\t} satisfies ArrayMetadata<Dtype>;\r\n\tawait location.store.set(\r\n\t\tlocation.resolve(\"zarr.json\").path,\r\n\t\tjson_encode_object(metadata),\r\n\t);\r\n\treturn new Array(location.store, location.path, metadata);\r\n}\r\n", "import type { ChunkQueue, Indices, Slice } from \"./types.js\";\r\n\r\n/** Similar to python's `range` function. Supports positive ranges only. */\r\nexport function* range(\r\n\tstart: number,\r\n\tstop?: number,\r\n\tstep = 1,\r\n): Iterable<number> {\r\n\tif (stop === undefined) {\r\n\t\tstop = start;\r\n\t\tstart = 0;\r\n\t}\r\n\tfor (let i = start; i < stop; i += step) {\r\n\t\tyield i;\r\n\t}\r\n}\r\n\r\n/**\r\n * python-like itertools.product generator\r\n * https://gist.github.com/cybercase/db7dde901d7070c98c48\r\n */\r\nexport function* product<T extends Array<Iterable<unknown>>>(\r\n\t...iterables: T\r\n): IterableIterator<{\r\n\t[K in keyof T]: T[K] extends Iterable<infer U> ? U : never;\r\n}> {\r\n\tif (iterables.length === 0) {\r\n\t\treturn;\r\n\t}\r\n\t// make a list of iterators from the iterables\r\n\tconst iterators = iterables.map((it) => it[Symbol.iterator]());\r\n\tconst results = iterators.map((it) => it.next());\r\n\tif (results.some((r) => r.done)) {\r\n\t\tthrow new Error(\"Input contains an empty iterator.\");\r\n\t}\r\n\tfor (let i = 0; ; ) {\r\n\t\tif (results[i].done) {\r\n\t\t\t// reset the current iterator\r\n\t\t\titerators[i] = iterables[i][Symbol.iterator]();\r\n\t\t\tresults[i] = iterators[i].next();\r\n\t\t\t// advance, and exit if we've reached the end\r\n\t\t\tif (++i >= iterators.length) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// @ts-expect-error - TS can't infer this\r\n\t\t\tyield results.map(({ value }) => value);\r\n\t\t\ti = 0;\r\n\t\t}\r\n\t\tresults[i] = iterators[i].next();\r\n\t}\r\n}\r\n\r\n// https://github.com/python/cpython/blob/263c0dd16017613c5ea2fbfc270be4de2b41b5ad/Objects/sliceobject.c#L376-L519\r\nexport function slice_indices(\r\n\t{ start, stop, step }: Slice,\r\n\tlength: number,\r\n): Indices {\r\n\tif (step === 0) {\r\n\t\tthrow new Error(\"slice step cannot be zero\");\r\n\t}\r\n\tstep = step ?? 1;\r\n\tconst step_is_negative = step < 0;\r\n\r\n\t/* Find lower and upper bounds for start and stop. */\r\n\tconst [lower, upper] = step_is_negative ? [-1, length - 1] : [0, length];\r\n\r\n\t/* Compute start. */\r\n\tif (start === null) {\r\n\t\tstart = step_is_negative ? upper : lower;\r\n\t} else {\r\n\t\tif (start < 0) {\r\n\t\t\tstart += length;\r\n\t\t\tif (start < lower) {\r\n\t\t\t\tstart = lower;\r\n\t\t\t}\r\n\t\t} else if (start > upper) {\r\n\t\t\tstart = upper;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Compute stop. */\r\n\tif (stop === null) {\r\n\t\tstop = step_is_negative ? lower : upper;\r\n\t} else {\r\n\t\tif (stop < 0) {\r\n\t\t\tstop += length;\r\n\t\t\tif (stop < lower) {\r\n\t\t\t\tstop = lower;\r\n\t\t\t}\r\n\t\t} else if (stop > upper) {\r\n\t\t\tstop = upper;\r\n\t\t}\r\n\t}\r\n\r\n\treturn [start, stop, step];\r\n}\r\n\r\n/** @category Utilty */\r\nexport function slice(stop: number | null): Slice;\r\nexport function slice(\r\n\tstart: number | null,\r\n\tstop?: number | null,\r\n\tstep?: number | null,\r\n): Slice;\r\nexport function slice(\r\n\tstart: number | null,\r\n\tstop?: number | null,\r\n\tstep: number | null = null,\r\n): Slice {\r\n\tif (stop === undefined) {\r\n\t\tstop = start;\r\n\t\tstart = null;\r\n\t}\r\n\treturn {\r\n\t\tstart,\r\n\t\tstop,\r\n\t\tstep,\r\n\t};\r\n}\r\n\r\n/** Built-in \"queue\" for awaiting promises. */\r\nexport function create_queue(): ChunkQueue {\r\n\tconst promises: Promise<void>[] = [];\r\n\treturn {\r\n\t\tadd: (fn) => promises.push(fn()),\r\n\t\tonIdle: () => Promise.all(promises),\r\n\t};\r\n}\r\n", "import type { Indices, Slice } from \"./types.js\";\r\nimport { product, range, slice, slice_indices } from \"./util.js\";\r\n\r\nexport class IndexError extends Error {\r\n\tconstructor(msg: string) {\r\n\t\tsuper(msg);\r\n\t\tthis.name = \"IndexError\";\r\n\t}\r\n}\r\n\r\nfunction err_too_many_indices(\r\n\tselection: (number | Slice)[],\r\n\tshape: readonly number[],\r\n) {\r\n\tthrow new IndexError(\r\n\t\t`too many indicies for array; expected ${shape.length}, got ${selection.length}`,\r\n\t);\r\n}\r\n\r\nfunction err_boundscheck(dim_len: number) {\r\n\tthrow new IndexError(\r\n\t\t`index out of bounds for dimension with length ${dim_len}`,\r\n\t);\r\n}\r\n\r\nfunction err_negative_step() {\r\n\tthrow new IndexError(\"only slices with step >= 1 are supported\");\r\n}\r\n\r\nfunction check_selection_length(\r\n\tselection: (number | Slice)[],\r\n\tshape: readonly number[],\r\n) {\r\n\tif (selection.length > shape.length) {\r\n\t\terr_too_many_indices(selection, shape);\r\n\t}\r\n}\r\n\r\nexport function normalize_integer_selection(dim_sel: number, dim_len: number) {\r\n\t// normalize type to int\r\n\tdim_sel = Math.trunc(dim_sel);\r\n\t// handle wraparound\r\n\tif (dim_sel < 0) {\r\n\t\tdim_sel = dim_len + dim_sel;\r\n\t}\r\n\t// handle out of bounds\r\n\tif (dim_sel >= dim_len || dim_sel < 0) {\r\n\t\terr_boundscheck(dim_len);\r\n\t}\r\n\treturn dim_sel;\r\n}\r\n\r\ninterface IntChunkDimProjection {\r\n\tdim_chunk_ix: number;\r\n\tdim_chunk_sel: number;\r\n}\r\n\r\ninterface IntDimIndexerProps {\r\n\tdim_sel: number;\r\n\tdim_len: number;\r\n\tdim_chunk_len: number;\r\n}\r\n\r\nclass IntDimIndexer {\r\n\tdim_sel: number;\r\n\tdim_len: number;\r\n\tdim_chunk_len: number;\r\n\tnitems: 1;\r\n\r\n\tconstructor({ dim_sel, dim_len, dim_chunk_len }: IntDimIndexerProps) {\r\n\t\t// normalize\r\n\t\tdim_sel = normalize_integer_selection(dim_sel, dim_len);\r\n\t\t// store properties\r\n\t\tthis.dim_sel = dim_sel;\r\n\t\tthis.dim_len = dim_len;\r\n\t\tthis.dim_chunk_len = dim_chunk_len;\r\n\t\tthis.nitems = 1;\r\n\t}\r\n\r\n\t*[Symbol.iterator](): IterableIterator<IntChunkDimProjection> {\r\n\t\tconst dim_chunk_ix = Math.floor(this.dim_sel / this.dim_chunk_len);\r\n\t\tconst dim_offset = dim_chunk_ix * this.dim_chunk_len;\r\n\t\tconst dim_chunk_sel = this.dim_sel - dim_offset;\r\n\t\tyield { dim_chunk_ix, dim_chunk_sel };\r\n\t}\r\n}\r\n\r\ninterface SliceChunkDimProjection {\r\n\tdim_chunk_ix: number;\r\n\tdim_chunk_sel: Indices;\r\n\tdim_out_sel: Indices;\r\n}\r\n\r\ninterface SliceDimIndexerProps {\r\n\tdim_sel: Slice;\r\n\tdim_len: number;\r\n\tdim_chunk_len: number;\r\n}\r\n\r\nclass SliceDimIndexer {\r\n\tstart: number;\r\n\tstop: number;\r\n\tstep: number;\r\n\r\n\tdim_len: number;\r\n\tdim_chunk_len: number;\r\n\tnitems: number;\r\n\tnchunks: number;\r\n\r\n\tconstructor({ dim_sel, dim_len, dim_chunk_len }: SliceDimIndexerProps) {\r\n\t\t// normalize\r\n\t\tconst [start, stop, step] = slice_indices(dim_sel, dim_len);\r\n\t\tthis.start = start;\r\n\t\tthis.stop = stop;\r\n\t\tthis.step = step;\r\n\t\tif (this.step < 1) err_negative_step();\r\n\t\t// store properties\r\n\t\tthis.dim_len = dim_len;\r\n\t\tthis.dim_chunk_len = dim_chunk_len;\r\n\t\tthis.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\r\n\t\tthis.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);\r\n\t}\r\n\r\n\t*[Symbol.iterator](): IterableIterator<SliceChunkDimProjection> {\r\n\t\t// figure out the range of chunks we need to visit\r\n\t\tconst dim_chunk_ix_from = Math.floor(this.start / this.dim_chunk_len);\r\n\t\tconst dim_chunk_ix_to = Math.ceil(this.stop / this.dim_chunk_len);\r\n\t\tfor (const dim_chunk_ix of range(dim_chunk_ix_from, dim_chunk_ix_to)) {\r\n\t\t\t// compute offsets for chunk within overall array\r\n\t\t\tconst dim_offset = dim_chunk_ix * this.dim_chunk_len;\r\n\t\t\tconst dim_limit = Math.min(\r\n\t\t\t\tthis.dim_len,\r\n\t\t\t\t(dim_chunk_ix + 1) * this.dim_chunk_len,\r\n\t\t\t);\r\n\t\t\t// determine chunk length, accounting for trailing chunk\r\n\t\t\tconst dim_chunk_len = dim_limit - dim_offset;\r\n\r\n\t\t\tlet dim_out_offset = 0;\r\n\t\t\tlet dim_chunk_sel_start = 0;\r\n\t\t\tif (this.start < dim_offset) {\r\n\t\t\t\t// selection start before current chunk\r\n\t\t\t\tconst remainder = (dim_offset - this.start) % this.step;\r\n\t\t\t\tif (remainder) dim_chunk_sel_start += this.step - remainder;\r\n\t\t\t\t// compute number of previous items, provides offset into output array\r\n\t\t\t\tdim_out_offset = Math.ceil((dim_offset - this.start) / this.step);\r\n\t\t\t} else {\r\n\t\t\t\t// selection starts within current chunk\r\n\t\t\t\tdim_chunk_sel_start = this.start - dim_offset;\r\n\t\t\t}\r\n\t\t\t// selection starts within current chunk if true,\r\n\t\t\t// otherwise selection ends after current chunk.\r\n\t\t\tconst dim_chunk_sel_stop =\r\n\t\t\t\tthis.stop > dim_limit ? dim_chunk_len : this.stop - dim_offset;\r\n\r\n\t\t\tconst dim_chunk_sel: Indices = [\r\n\t\t\t\tdim_chunk_sel_start,\r\n\t\t\t\tdim_chunk_sel_stop,\r\n\t\t\t\tthis.step,\r\n\t\t\t];\r\n\t\t\tconst dim_chunk_nitems = Math.ceil(\r\n\t\t\t\t(dim_chunk_sel_stop - dim_chunk_sel_start) / this.step,\r\n\t\t\t);\r\n\r\n\t\t\tconst dim_out_sel: Indices = [\r\n\t\t\t\tdim_out_offset,\r\n\t\t\t\tdim_out_offset + dim_chunk_nitems,\r\n\t\t\t\t1,\r\n\t\t\t];\r\n\t\t\tyield { dim_chunk_ix, dim_chunk_sel, dim_out_sel };\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function normalize_selection(\r\n\tselection: null | (Slice | null | number)[],\r\n\tshape: readonly number[],\r\n): (number | Slice)[] {\r\n\tlet normalized: (number | Slice)[] = [];\r\n\tif (selection === null) {\r\n\t\tnormalized = shape.map((_) => slice(null));\r\n\t} else if (Array.isArray(selection)) {\r\n\t\tnormalized = selection.map((s) => s ?? slice(null));\r\n\t}\r\n\tcheck_selection_length(normalized, shape);\r\n\treturn normalized;\r\n}\r\n\r\ninterface BasicIndexerProps {\r\n\tselection: null | (null | number | Slice)[];\r\n\tshape: readonly number[];\r\n\tchunk_shape: readonly number[];\r\n}\r\n\r\nexport type IndexerProjection =\r\n\t| { from: number; to: null }\r\n\t| {\r\n\t\t\tfrom: Indices;\r\n\t\t\tto: Indices;\r\n\t  };\r\n\r\ninterface ChunkProjection {\r\n\tchunk_coords: number[];\r\n\tmapping: IndexerProjection[];\r\n}\r\n\r\nexport class BasicIndexer {\r\n\tdim_indexers: (SliceDimIndexer | IntDimIndexer)[];\r\n\tshape: number[];\r\n\r\n\tconstructor({ selection, shape, chunk_shape }: BasicIndexerProps) {\r\n\t\t// setup per-dimension indexers\r\n\t\tthis.dim_indexers = normalize_selection(selection, shape).map(\r\n\t\t\t(dim_sel, i) => {\r\n\t\t\t\treturn new (\r\n\t\t\t\t\ttypeof dim_sel === \"number\" ? IntDimIndexer : SliceDimIndexer\r\n\t\t\t\t)({\r\n\t\t\t\t\t// @ts-expect-error ts inference not strong enough to know correct chunk\r\n\t\t\t\t\tdim_sel: dim_sel,\r\n\t\t\t\t\tdim_len: shape[i],\r\n\t\t\t\t\tdim_chunk_len: chunk_shape[i],\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t);\r\n\t\tthis.shape = this.dim_indexers\r\n\t\t\t.filter((ixr) => ixr instanceof SliceDimIndexer)\r\n\t\t\t.map((sixr) => sixr.nitems);\r\n\t}\r\n\r\n\t*[Symbol.iterator](): IterableIterator<ChunkProjection> {\r\n\t\tfor (const dim_projections of product(...this.dim_indexers)) {\r\n\t\t\tconst chunk_coords = dim_projections.map((p) => p.dim_chunk_ix);\r\n\t\t\tconst mapping: IndexerProjection[] = dim_projections.map((p) => {\r\n\t\t\t\tif (\"dim_out_sel\" in p) {\r\n\t\t\t\t\treturn { from: p.dim_chunk_sel, to: p.dim_out_sel };\r\n\t\t\t\t}\r\n\t\t\t\treturn { from: p.dim_chunk_sel, to: null };\r\n\t\t\t});\r\n\t\t\tyield { chunk_coords, mapping };\r\n\t\t}\r\n\t}\r\n}\r\n", "import type { Readable } from \"@zarrita/storage\";\r\n\r\nimport { type Array, get_context } from \"../hierarchy.js\";\r\nimport type { Chunk, DataType, Scalar, TypedArray } from \"../metadata.js\";\r\nimport { BasicIndexer } from \"./indexer.js\";\r\nimport type {\r\n\tGetOptions,\r\n\tPrepare,\r\n\tSetFromChunk,\r\n\tSetScalar,\r\n\tSlice,\r\n} from \"./types.js\";\r\nimport { create_queue } from \"./util.js\";\r\n\r\nfunction unwrap<D extends DataType>(\r\n\tarr: TypedArray<D>,\r\n\tidx: number,\r\n): Scalar<D> {\r\n\treturn (\"get\" in arr ? arr.get(idx) : arr[idx]) as Scalar<D>;\r\n}\r\n\r\nexport async function get<\r\n\tD extends DataType,\r\n\tStore extends Readable,\r\n\tArr extends Chunk<D>,\r\n\tSel extends (null | Slice | number)[],\r\n>(\r\n\tarr: Array<D, Store>,\r\n\tselection: null | Sel,\r\n\topts: GetOptions<Parameters<Store[\"get\"]>[1]>,\r\n\tsetter: {\r\n\t\tprepare: Prepare<D, Arr>;\r\n\t\tset_scalar: SetScalar<D, Arr>;\r\n\t\tset_from_chunk: SetFromChunk<D, Arr>;\r\n\t},\r\n): Promise<\r\n\tnull extends Sel[number] ? Arr : Slice extends Sel[number] ? Arr : Scalar<D>\r\n> {\r\n\tlet context = get_context(arr);\r\n\tlet indexer = new BasicIndexer({\r\n\t\tselection,\r\n\t\tshape: arr.shape,\r\n\t\tchunk_shape: arr.chunks,\r\n\t});\r\n\r\n\tlet out = setter.prepare(\r\n\t\tnew context.TypedArray(indexer.shape.reduce((a, b) => a * b, 1)),\r\n\t\tindexer.shape,\r\n\t\tcontext.get_strides(indexer.shape),\r\n\t);\r\n\r\n\tlet queue = opts.create_queue?.() ?? create_queue();\r\n\tfor (const { chunk_coords, mapping } of indexer) {\r\n\t\tqueue.add(async () => {\r\n\t\t\tlet { data, shape, stride } = await arr.getChunk(chunk_coords, opts.opts);\r\n\t\t\tlet chunk = setter.prepare(data, shape, stride);\r\n\t\t\tsetter.set_from_chunk(out, chunk, mapping);\r\n\t\t});\r\n\t}\r\n\r\n\tawait queue.onIdle();\r\n\r\n\t// If the final out shape is empty, we just return a scalar.\r\n\t// @ts-expect-error - TS can't narrow this conditional type\r\n\treturn indexer.shape.length === 0 ? unwrap(out.data, 0) : out;\r\n}\r\n", "import type { Mutable } from \"@zarrita/storage\";\r\n\r\nimport { type Array, get_context } from \"../hierarchy.js\";\r\nimport type { Chunk, DataType, Scalar, TypedArray } from \"../metadata.js\";\r\nimport { BasicIndexer, type IndexerProjection } from \"./indexer.js\";\r\nimport type {\r\n\tIndices,\r\n\tPrepare,\r\n\tSetFromChunk,\r\n\tSetOptions,\r\n\tSetScalar,\r\n\tSlice,\r\n} from \"./types.js\";\r\nimport { create_queue } from \"./util.js\";\r\n\r\nfunction flip_indexer_projection(m: IndexerProjection) {\r\n\tif (m.to == null) return { from: m.to, to: m.from };\r\n\treturn { from: m.to, to: m.from };\r\n}\r\n\r\nexport async function set<Dtype extends DataType, Arr extends Chunk<Dtype>>(\r\n\tarr: Array<Dtype, Mutable>,\r\n\tselection: (number | Slice | null)[] | null,\r\n\tvalue: Scalar<Dtype> | Arr,\r\n\topts: SetOptions,\r\n\tsetter: {\r\n\t\tprepare: Prepare<Dtype, Arr>;\r\n\t\tset_scalar: SetScalar<Dtype, Arr>;\r\n\t\tset_from_chunk: SetFromChunk<Dtype, Arr>;\r\n\t},\r\n) {\r\n\tconst context = get_context(arr);\r\n\tif (context.kind === \"sharded\") {\r\n\t\tthrow new Error(\"Set not supported for sharded arrays.\");\r\n\t}\r\n\tconst indexer = new BasicIndexer({\r\n\t\tselection,\r\n\t\tshape: arr.shape,\r\n\t\tchunk_shape: arr.chunks,\r\n\t});\r\n\r\n\t// We iterate over all chunks which overlap the selection and thus contain data\r\n\t// that needs to be replaced. Each chunk is processed in turn, extracting the\r\n\t// necessary data from the value array and storing into the chunk array.\r\n\r\n\tconst chunk_size = arr.chunks.reduce((a, b) => a * b, 1);\r\n\tconst queue = opts.create_queue ? opts.create_queue() : create_queue();\r\n\r\n\t// N.B., it is an important optimisation that we only visit chunks which overlap\r\n\t// the selection. This minimises the number of iterations in the main for loop.\r\n\tfor (const { chunk_coords, mapping } of indexer) {\r\n\t\tconst chunk_selection = mapping.map((i) => i.from);\r\n\t\tconst flipped = mapping.map(flip_indexer_projection);\r\n\t\tqueue.add(async () => {\r\n\t\t\t// obtain key for chunk storage\r\n\t\t\tconst chunk_path = arr.resolve(\r\n\t\t\t\tcontext.encode_chunk_key(chunk_coords),\r\n\t\t\t).path;\r\n\r\n\t\t\tlet chunk_data: TypedArray<Dtype>;\r\n\t\t\tconst chunk_shape = arr.chunks.slice();\r\n\t\t\tconst chunk_stride = context.get_strides(chunk_shape);\r\n\r\n\t\t\tif (is_total_slice(chunk_selection, chunk_shape)) {\r\n\t\t\t\t// totally replace\r\n\t\t\t\tchunk_data = new context.TypedArray(chunk_size);\r\n\t\t\t\t// optimization: we are completely replacing the chunk, so no need\r\n\t\t\t\t// to access the exisiting chunk data\r\n\t\t\t\tif (typeof value === \"object\") {\r\n\t\t\t\t\t// Otherwise data just contiguous TypedArray\r\n\t\t\t\t\tconst chunk = setter.prepare(\r\n\t\t\t\t\t\tchunk_data,\r\n\t\t\t\t\t\tchunk_shape.slice(),\r\n\t\t\t\t\t\tchunk_stride.slice(),\r\n\t\t\t\t\t);\r\n\t\t\t\t\t// @ts-expect-error - Value is not a scalar\r\n\t\t\t\t\tsetter.set_from_chunk(chunk, value, flipped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// @ts-expect-error - Value is a scalar\r\n\t\t\t\t\tchunk_data.fill(value);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// partially replace the contents of this chunk\r\n\t\t\t\tchunk_data = await arr.getChunk(chunk_coords).then(({ data }) => data);\r\n\r\n\t\t\t\tconst chunk = setter.prepare(\r\n\t\t\t\t\tchunk_data,\r\n\t\t\t\t\tchunk_shape.slice(),\r\n\t\t\t\t\tchunk_stride.slice(),\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// Modify chunk data\r\n\t\t\t\tif (typeof value === \"object\") {\r\n\t\t\t\t\t// @ts-expect-error - Value is not a scalar\r\n\t\t\t\t\tsetter.set_from_chunk(chunk, value, flipped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsetter.set_scalar(chunk, chunk_selection, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tawait arr.store.set(\r\n\t\t\t\tchunk_path,\r\n\t\t\t\tawait context.codec.encode({\r\n\t\t\t\t\tdata: chunk_data,\r\n\t\t\t\t\tshape: chunk_shape,\r\n\t\t\t\t\tstride: chunk_stride,\r\n\t\t\t\t}),\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\tawait queue.onIdle();\r\n}\r\n\r\nfunction is_total_slice(\r\n\tselection: (number | Indices)[],\r\n\tshape: readonly number[],\r\n): selection is Indices[] {\r\n\t// all items are Indices and every slice is complete\r\n\treturn selection.every((s, i) => {\r\n\t\t// can't be a full selection\r\n\t\tif (typeof s === \"number\") return false;\r\n\t\t// explicit complete slice\r\n\t\tconst [start, stop, step] = s;\r\n\t\treturn stop - start === shape[i] && step === 1;\r\n\t});\r\n}\r\n", "import type { Mutable, Readable } from \"@zarrita/storage\";\r\n\r\nimport type { Array } from \"../hierarchy.js\";\r\nimport type {\r\n\tChunk,\r\n\tDataType,\r\n\tScalar,\r\n\tTypedArray,\r\n\tTypedArrayConstructor,\r\n} from \"../metadata.js\";\r\nimport { get as get_with_setter } from \"./get.js\";\r\nimport { set as set_with_setter } from \"./set.js\";\r\nimport type {\r\n\tGetOptions,\r\n\tIndices,\r\n\tProjection,\r\n\tSetOptions,\r\n\tSlice,\r\n} from \"./types.js\";\r\n\r\n/** A 1D \"view\" of an array that can be used to set values in the array. */\r\nfunction object_array_view<T>(arr: T[], offset = 0, size?: number) {\r\n\tlet length = size ?? arr.length - offset;\r\n\treturn {\r\n\t\tlength,\r\n\t\tsubarray(from: number, to: number = length) {\r\n\t\t\treturn object_array_view(arr, offset + from, to - from);\r\n\t\t},\r\n\t\tset(data: { get(idx: number): T; length: number }, start = 0) {\r\n\t\t\tfor (let i = 0; i < data.length; i++) {\r\n\t\t\t\tarr[offset + start + i] = data.get(i);\r\n\t\t\t}\r\n\t\t},\r\n\t\tget(index: number) {\r\n\t\t\treturn arr[offset + index];\r\n\t\t},\r\n\t};\r\n}\r\n\r\n/**\r\n * Convert a chunk to a Uint8Array that can be used with the binary\r\n * set functions. This is necessary because the binary set functions\r\n * require a contiguous block of memory, and allows us to support more than\r\n * just the browser's TypedArray objects.\r\n *\r\n * WARNING: This function is not meant to be used directly and is NOT type-safe.\r\n * In the case of `Array` instances, it will return a `object_array_view` of\r\n * the underlying, which is supported by our binary set functions.\r\n */\r\nfunction compat_chunk<D extends DataType>(\r\n\tarr: Chunk<D>,\r\n): {\r\n\tdata: Uint8Array;\r\n\tstride: number[];\r\n\tbytes_per_element: number;\r\n} {\r\n\tif (globalThis.Array.isArray(arr.data)) {\r\n\t\treturn {\r\n\t\t\t// @ts-expect-error\r\n\t\t\tdata: object_array_view(arr.data),\r\n\t\t\tstride: arr.stride,\r\n\t\t\tbytes_per_element: 1,\r\n\t\t};\r\n\t}\r\n\treturn {\r\n\t\tdata: new Uint8Array(\r\n\t\t\tarr.data.buffer,\r\n\t\t\tarr.data.byteOffset,\r\n\t\t\tarr.data.byteLength,\r\n\t\t),\r\n\t\tstride: arr.stride,\r\n\t\tbytes_per_element: arr.data.BYTES_PER_ELEMENT,\r\n\t};\r\n}\r\n\r\n/** Hack to get the constructor of a typed array constructor from an existing TypedArray. */\r\nfunction get_typed_array_constructor<D extends Exclude<DataType, \"v2:object\">>(\r\n\tarr: TypedArray<D>,\r\n): TypedArrayConstructor<D> {\r\n\tif (\"chars\" in arr) {\r\n\t\t// our custom TypedArray needs to bind the number of characters per\r\n\t\t// element to the constructor.\r\n\t\treturn arr.constructor.bind(null, arr.chars);\r\n\t}\r\n\treturn arr.constructor as TypedArrayConstructor<D>;\r\n}\r\n\r\n/**\r\n * Convert a scalar to a Uint8Array that can be used with the binary\r\n * set functions. This is necessary because the binary set functions\r\n * require a contiguous block of memory, and allows us to support more\r\n * than just the browser's TypedArray objects.\r\n *\r\n * WARNING: This function is not meant to be used directly and is NOT type-safe.\r\n * In the case of `Array` instances, it will return a `object_array_view` of\r\n * the scalar, which is supported by our binary set functions.\r\n */\r\nfunction compat_scalar<D extends DataType>(\r\n\tarr: Chunk<D>,\r\n\tvalue: Scalar<D>,\r\n): Uint8Array {\r\n\tif (globalThis.Array.isArray(arr.data)) {\r\n\t\t// @ts-expect-error\r\n\t\treturn object_array_view([value]);\r\n\t}\r\n\tlet TypedArray = get_typed_array_constructor(arr.data);\r\n\t// @ts-expect-error - value is a scalar and matches\r\n\tlet data = new TypedArray([value]);\r\n\treturn new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n}\r\n\r\nexport const setter = {\r\n\tprepare<D extends DataType>(\r\n\t\tdata: TypedArray<D>,\r\n\t\tshape: number[],\r\n\t\tstride: number[],\r\n\t) {\r\n\t\treturn { data, shape, stride };\r\n\t},\r\n\tset_scalar<D extends DataType>(\r\n\t\tdest: Chunk<D>,\r\n\t\tsel: (number | Indices)[],\r\n\t\tvalue: Scalar<D>,\r\n\t) {\r\n\t\tlet view = compat_chunk(dest);\r\n\t\tset_scalar_binary(\r\n\t\t\tview,\r\n\t\t\tsel,\r\n\t\t\tcompat_scalar(dest, value),\r\n\t\t\tview.bytes_per_element,\r\n\t\t);\r\n\t},\r\n\tset_from_chunk<D extends DataType>(\r\n\t\tdest: Chunk<D>,\r\n\t\tsrc: Chunk<D>,\r\n\t\tprojections: Projection[],\r\n\t) {\r\n\t\tlet view = compat_chunk(dest);\r\n\t\tset_from_chunk_binary(\r\n\t\t\tview,\r\n\t\t\tcompat_chunk(src),\r\n\t\t\tview.bytes_per_element,\r\n\t\t\tprojections,\r\n\t\t);\r\n\t},\r\n};\r\n\r\n/** @category Utility */\r\nexport async function get<\r\n\tD extends DataType,\r\n\tStore extends Readable,\r\n\tSel extends (null | Slice | number)[],\r\n>(\r\n\tarr: Array<D, Store>,\r\n\tselection: Sel | null = null,\r\n\topts: GetOptions<Parameters<Store[\"get\"]>[1]> = {},\r\n): Promise<\r\n\tnull extends Sel[number]\r\n\t\t? Chunk<D>\r\n\t\t: Slice extends Sel[number]\r\n\t\t\t? Chunk<D>\r\n\t\t\t: Scalar<D>\r\n> {\r\n\treturn get_with_setter<D, Store, Chunk<D>, Sel>(arr, selection, opts, setter);\r\n}\r\n\r\n/** @category Utility */\r\nexport async function set<D extends DataType>(\r\n\tarr: Array<D, Mutable>,\r\n\tselection: (null | Slice | number)[] | null,\r\n\tvalue: Scalar<D> | Chunk<D>,\r\n\topts: SetOptions = {},\r\n): Promise<void> {\r\n\treturn set_with_setter<D, Chunk<D>>(arr, selection, value, opts, setter);\r\n}\r\n\r\nfunction indices_len(start: number, stop: number, step: number) {\r\n\tif (step < 0 && stop < start) {\r\n\t\treturn Math.floor((start - stop - 1) / -step) + 1;\r\n\t}\r\n\tif (start < stop) return Math.floor((stop - start - 1) / step) + 1;\r\n\treturn 0;\r\n}\r\n\r\nfunction set_scalar_binary(\r\n\tout: { data: Uint8Array; stride: number[] },\r\n\tout_selection: (Indices | number)[],\r\n\tvalue: Uint8Array,\r\n\tbytes_per_element: number,\r\n) {\r\n\tif (out_selection.length === 0) {\r\n\t\tout.data.set(value, 0);\r\n\t\treturn;\r\n\t}\r\n\tconst [slice, ...slices] = out_selection;\r\n\tconst [curr_stride, ...stride] = out.stride;\r\n\tif (typeof slice === \"number\") {\r\n\t\tconst data = out.data.subarray(curr_stride * slice * bytes_per_element);\r\n\t\tset_scalar_binary({ data, stride }, slices, value, bytes_per_element);\r\n\t\treturn;\r\n\t}\r\n\tconst [from, to, step] = slice;\r\n\tconst len = indices_len(from, to, step);\r\n\tif (slices.length === 0) {\r\n\t\tfor (let i = 0; i < len; i++) {\r\n\t\t\tout.data.set(value, curr_stride * (from + step * i) * bytes_per_element);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tconst data = out.data.subarray(\r\n\t\t\tcurr_stride * (from + step * i) * bytes_per_element,\r\n\t\t);\r\n\t\tset_scalar_binary({ data, stride }, slices, value, bytes_per_element);\r\n\t}\r\n}\r\n\r\nfunction set_from_chunk_binary(\r\n\tdest: { data: Uint8Array; stride: number[] },\r\n\tsrc: { data: Uint8Array; stride: number[] },\r\n\tbytes_per_element: number,\r\n\tprojections: Projection[],\r\n) {\r\n\tconst [proj, ...projs] = projections;\r\n\tconst [dstride, ...dstrides] = dest.stride;\r\n\tconst [sstride, ...sstrides] = src.stride;\r\n\tif (proj.from === null) {\r\n\t\tif (projs.length === 0) {\r\n\t\t\tdest.data.set(\r\n\t\t\t\tsrc.data.subarray(0, bytes_per_element),\r\n\t\t\t\tproj.to * bytes_per_element,\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tset_from_chunk_binary(\r\n\t\t\t{\r\n\t\t\t\tdata: dest.data.subarray(dstride * proj.to * bytes_per_element),\r\n\t\t\t\tstride: dstrides,\r\n\t\t\t},\r\n\t\t\tsrc,\r\n\t\t\tbytes_per_element,\r\n\t\t\tprojs,\r\n\t\t);\r\n\t\treturn;\r\n\t}\r\n\tif (proj.to === null) {\r\n\t\tif (projs.length === 0) {\r\n\t\t\tlet offset = proj.from * bytes_per_element;\r\n\t\t\tdest.data.set(src.data.subarray(offset, offset + bytes_per_element), 0);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tset_from_chunk_binary(\r\n\t\t\tdest,\r\n\t\t\t{\r\n\t\t\t\tdata: src.data.subarray(sstride * proj.from * bytes_per_element),\r\n\t\t\t\tstride: sstrides,\r\n\t\t\t},\r\n\t\t\tbytes_per_element,\r\n\t\t\tprojs,\r\n\t\t);\r\n\t\treturn;\r\n\t}\r\n\tconst [from, to, step] = proj.to;\r\n\tconst [sfrom, _, sstep] = proj.from;\r\n\tconst len = indices_len(from, to, step);\r\n\tif (projs.length === 0) {\r\n\t\t// NB: we have a contiguous block of memory\r\n\t\t// so we can just copy over all the data at once.\r\n\t\tif (step === 1 && sstep === 1 && dstride === 1 && sstride === 1) {\r\n\t\t\tlet offset = sfrom * bytes_per_element;\r\n\t\t\tlet size = len * bytes_per_element;\r\n\t\t\tdest.data.set(\r\n\t\t\t\tsrc.data.subarray(offset, offset + size),\r\n\t\t\t\tfrom * bytes_per_element,\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Otherwise, we have to copy over each element individually.\r\n\t\tfor (let i = 0; i < len; i++) {\r\n\t\t\tlet offset = sstride * (sfrom + sstep * i) * bytes_per_element;\r\n\t\t\tdest.data.set(\r\n\t\t\t\tsrc.data.subarray(offset, offset + bytes_per_element),\r\n\t\t\t\tdstride * (from + step * i) * bytes_per_element,\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tfor (let i = 0; i < len; i++) {\r\n\t\tset_from_chunk_binary(\r\n\t\t\t{\r\n\t\t\t\tdata: dest.data.subarray(\r\n\t\t\t\t\tdstride * (from + i * step) * bytes_per_element,\r\n\t\t\t\t),\r\n\t\t\t\tstride: dstrides,\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tdata: src.data.subarray(\r\n\t\t\t\t\tsstride * (sfrom + i * sstep) * bytes_per_element,\r\n\t\t\t\t),\r\n\t\t\t\tstride: sstrides,\r\n\t\t\t},\r\n\t\t\tbytes_per_element,\r\n\t\t\tprojs,\r\n\t\t);\r\n\t}\r\n}\r\n", "import type { Readable } from \"@zarrita/storage\";\r\nimport { KeyError, NodeNotFoundError } from \"./errors.js\";\r\nimport { Array, Group, Location } from \"./hierarchy.js\";\r\nimport type {\r\n\tArrayMetadata,\r\n\tAttributes,\r\n\tDataType,\r\n\tGroupMetadata,\r\n} from \"./metadata.js\";\r\nimport {\r\n\tensure_correct_scalar,\r\n\tjson_decode_object,\r\n\trethrow_unless,\r\n\tv2_to_v3_array_metadata,\r\n\tv2_to_v3_group_metadata,\r\n} from \"./util.js\";\r\n\r\nlet VERSION_COUNTER = create_version_counter();\r\nfunction create_version_counter() {\r\n\tlet version_counts = new WeakMap<Readable, { v2: number; v3: number }>();\r\n\tfunction get_counts(store: Readable) {\r\n\t\tlet counts = version_counts.get(store) ?? { v2: 0, v3: 0 };\r\n\t\tversion_counts.set(store, counts);\r\n\t\treturn counts;\r\n\t}\r\n\treturn {\r\n\t\tincrement(store: Readable, version: \"v2\" | \"v3\") {\r\n\t\t\tget_counts(store)[version] += 1;\r\n\t\t},\r\n\t\tversion_max(store: Readable): \"v2\" | \"v3\" {\r\n\t\t\tlet counts = get_counts(store);\r\n\t\t\treturn counts.v3 > counts.v2 ? \"v3\" : \"v2\";\r\n\t\t},\r\n\t};\r\n}\r\n\r\nasync function load_attrs(location: Location<Readable>): Promise<Attributes> {\r\n\tlet meta_bytes = await location.store.get(location.resolve(\".zattrs\").path);\r\n\tif (!meta_bytes) return {};\r\n\treturn json_decode_object(meta_bytes);\r\n}\r\n\r\nfunction open_v2<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind: \"group\"; attrs?: boolean },\r\n): Promise<Group<Store>>;\r\n\r\nfunction open_v2<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind: \"array\"; attrs?: boolean },\r\n): Promise<Array<DataType, Store>>;\r\n\r\nfunction open_v2<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions?: { kind?: \"array\" | \"group\"; attrs?: boolean },\r\n): Promise<Array<DataType, Store> | Group<Store>>;\r\n\r\nasync function open_v2<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind?: \"array\" | \"group\"; attrs?: boolean } = {},\r\n) {\r\n\tlet loc = \"store\" in location ? location : new Location(location);\r\n\tlet attrs = {};\r\n\tif (options.attrs ?? true) attrs = await load_attrs(loc);\r\n\tif (options.kind === \"array\") return open_array_v2(loc, attrs);\r\n\tif (options.kind === \"group\") return open_group_v2(loc, attrs);\r\n\treturn open_array_v2(loc, attrs).catch((err) => {\r\n\t\trethrow_unless(err, NodeNotFoundError);\r\n\t\treturn open_group_v2(loc, attrs);\r\n\t});\r\n}\r\n\r\nasync function open_array_v2<Store extends Readable>(\r\n\tlocation: Location<Store>,\r\n\tattrs: Attributes,\r\n) {\r\n\tlet { path } = location.resolve(\".zarray\");\r\n\tlet meta = await location.store.get(path);\r\n\tif (!meta) {\r\n\t\tthrow new NodeNotFoundError(\"v2 array\", {\r\n\t\t\tcause: new KeyError(path),\r\n\t\t});\r\n\t}\r\n\tVERSION_COUNTER.increment(location.store, \"v2\");\r\n\treturn new Array(\r\n\t\tlocation.store,\r\n\t\tlocation.path,\r\n\t\tv2_to_v3_array_metadata(json_decode_object(meta), attrs),\r\n\t);\r\n}\r\n\r\nasync function open_group_v2<Store extends Readable>(\r\n\tlocation: Location<Store>,\r\n\tattrs: Attributes,\r\n) {\r\n\tlet { path } = location.resolve(\".zgroup\");\r\n\tlet meta = await location.store.get(path);\r\n\tif (!meta) {\r\n\t\tthrow new NodeNotFoundError(\"v2 group\", {\r\n\t\t\tcause: new KeyError(path),\r\n\t\t});\r\n\t}\r\n\tVERSION_COUNTER.increment(location.store, \"v2\");\r\n\treturn new Group(\r\n\t\tlocation.store,\r\n\t\tlocation.path,\r\n\t\tv2_to_v3_group_metadata(json_decode_object(meta), attrs),\r\n\t);\r\n}\r\n\r\nasync function _open_v3<Store extends Readable>(location: Location<Store>) {\r\n\tlet { store, path } = location.resolve(\"zarr.json\");\r\n\tlet meta = await location.store.get(path);\r\n\tif (!meta) {\r\n\t\tthrow new NodeNotFoundError(\"v3 array or group\", {\r\n\t\t\tcause: new KeyError(path),\r\n\t\t});\r\n\t}\r\n\tlet meta_doc: ArrayMetadata<DataType> | GroupMetadata =\r\n\t\tjson_decode_object(meta);\r\n\tif (meta_doc.node_type === \"array\") {\r\n\t\tmeta_doc.fill_value = ensure_correct_scalar(meta_doc);\r\n\t}\r\n\treturn meta_doc.node_type === \"array\"\r\n\t\t? new Array(store, location.path, meta_doc)\r\n\t\t: new Group(store, location.path, meta_doc);\r\n}\r\n\r\nfunction open_v3<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind: \"group\" },\r\n): Promise<Group<Store>>;\r\n\r\nfunction open_v3<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind: \"array\" },\r\n): Promise<Array<DataType, Store>>;\r\n\r\nfunction open_v3<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n): Promise<Array<DataType, Store> | Group<Store>>;\r\n\r\nfunction open_v3<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n): Promise<Array<DataType, Store> | Group<Store>>;\r\n\r\nasync function open_v3<Store extends Readable>(\r\n\tlocation: Location<Store>,\r\n\toptions: { kind?: \"array\" | \"group\" } = {},\r\n): Promise<Array<DataType, Store> | Group<Store>> {\r\n\tlet loc = \"store\" in location ? location : new Location(location);\r\n\tlet node = await _open_v3(loc);\r\n\tVERSION_COUNTER.increment(loc.store, \"v3\");\r\n\tif (options.kind === undefined) return node;\r\n\tif (options.kind === \"array\" && node instanceof Array) return node;\r\n\tif (options.kind === \"group\" && node instanceof Group) return node;\r\n\tlet kind = node instanceof Array ? \"array\" : \"group\";\r\n\tthrow new Error(`Expected node of kind ${options.kind}, found ${kind}.`);\r\n}\r\n\r\nexport function open<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind: \"group\" },\r\n): Promise<Group<Store>>;\r\n\r\nexport function open<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind: \"array\" },\r\n): Promise<Array<DataType, Store>>;\r\n\r\nexport async function open<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind?: \"array\" | \"group\" },\r\n): Promise<Array<DataType, Store> | Group<Store>>;\r\n\r\nexport function open<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n): Promise<Array<DataType, Store> | Group<Store>>;\r\n\r\nexport function open<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n): Promise<Array<DataType, Store> | Group<Store>>;\r\n\r\nexport async function open<Store extends Readable>(\r\n\tlocation: Location<Store> | Store,\r\n\toptions: { kind?: \"array\" | \"group\" } = {},\r\n): Promise<Array<DataType, Store> | Group<Store>> {\r\n\tlet store = \"store\" in location ? location.store : location;\r\n\tlet version_max = VERSION_COUNTER.version_max(store);\r\n\t// Use the open function for the version with the most successful opens.\r\n\t// Note that here we use the dot syntax to access the open functions\r\n\t// because this enables us to use vi.spyOn during testing.\r\n\tlet open_primary = version_max === \"v2\" ? open.v2 : open.v3;\r\n\tlet open_secondary = version_max === \"v2\" ? open.v3 : open.v2;\r\n\treturn open_primary(location, options).catch((err) => {\r\n\t\trethrow_unless(err, NodeNotFoundError);\r\n\t\treturn open_secondary(location, options);\r\n\t});\r\n}\r\n\r\nopen.v2 = open_v2;\r\nopen.v3 = open_v3;\r\n"],
  "mappings": "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",
  "names": ["root", "range", "bytes_per_element", "_bytes", "_shape", "_bytes", "_a", "_a", "opts", "root", "_a", "native_order", "_metadata", "Array", "Array", "setter", "_a", "setter", "get", "set", "bytes_per_element", "slice", "Array"]
}
