{
  "version": 3,
  "sources": ["../../unzipit/dist/unzipit.module.js"],
  "sourcesContent": ["/* unzipit@1.4.3, license MIT */\n/* global SharedArrayBuffer, process */\n\nfunction readBlobAsArrayBuffer(blob) {\n  if (blob.arrayBuffer) {\n    return blob.arrayBuffer();\n  }\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener('loadend', () => {\n      resolve(reader.result);\n    });\n    reader.addEventListener('error', reject);\n    reader.readAsArrayBuffer(blob);\n  });\n}\n\nasync function readBlobAsUint8Array(blob) {\n  const arrayBuffer = await readBlobAsArrayBuffer(blob);\n  return new Uint8Array(arrayBuffer);\n}\n\nfunction isBlob(v) {\n  return typeof Blob !== 'undefined' && v instanceof Blob;\n}\n\nfunction isSharedArrayBuffer(b) {\n  return typeof SharedArrayBuffer !== 'undefined' && b instanceof SharedArrayBuffer;\n}\n\nconst isNode =\n    (typeof process !== 'undefined') &&\n    process.versions &&\n    (typeof process.versions.node !== 'undefined') &&\n    (typeof process.versions.electron === 'undefined');\n\nfunction isTypedArraySameAsArrayBuffer(typedArray) {\n  return typedArray.byteOffset === 0 && typedArray.byteLength === typedArray.buffer.byteLength;\n}\n\nclass ArrayBufferReader {\n  constructor(arrayBufferOrView) {\n    this.typedArray = (arrayBufferOrView instanceof ArrayBuffer || isSharedArrayBuffer(arrayBufferOrView))\n       ? new Uint8Array(arrayBufferOrView)\n       : new Uint8Array(arrayBufferOrView.buffer, arrayBufferOrView.byteOffset, arrayBufferOrView.byteLength);\n  }\n  async getLength() {\n    return this.typedArray.byteLength;\n  }\n  async read(offset, length) {\n    return new Uint8Array(this.typedArray.buffer, this.typedArray.byteOffset + offset, length);\n  }\n}\n\nclass BlobReader {\n  constructor(blob) {\n    this.blob = blob;\n  }\n  async getLength() {\n    return this.blob.size;\n  }\n  async read(offset, length) {\n    const blob = this.blob.slice(offset, offset + length);\n    const arrayBuffer = await readBlobAsArrayBuffer(blob);\n    return new Uint8Array(arrayBuffer);\n  }\n  async sliceAsBlob(offset, length, type = '') {\n    return this.blob.slice(offset, offset + length, type);\n  }\n}\n\nclass HTTPRangeReader {\n  constructor(url) {\n    this.url = url;\n  }\n  async getLength() {\n    if (this.length === undefined) {\n      const req = await fetch(this.url, { method: 'HEAD' });\n      if (!req.ok) {\n        throw new Error(`failed http request ${this.url}, status: ${req.status}: ${req.statusText}`);\n      }\n      this.length = parseInt(req.headers.get('content-length'));\n      if (Number.isNaN(this.length)) {\n        throw Error('could not get length');\n      }\n    }\n    return this.length;\n  }\n  async read(offset, size) {\n    if (size === 0) {\n      return new Uint8Array(0);\n    }\n    const req = await fetch(this.url, {\n      headers: {\n        Range: `bytes=${offset}-${offset + size - 1}`,\n      },\n    });\n    if (!req.ok) {\n      throw new Error(`failed http request ${this.url}, status: ${req.status} offset: ${offset} size: ${size}: ${req.statusText}`);\n    }\n    const buffer = await req.arrayBuffer();\n    return new Uint8Array(buffer);\n  }\n}\n\nfunction inflate(data, buf) {\n\tvar u8=Uint8Array;\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\n\tvar bitsF = _bitsF, bitsE = _bitsE, decodeTiny = _decodeTiny, get17 = _get17;\n\t\n\tvar noBuf = (buf==null);\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\n\t\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\n\tvar off = 0, pos = 0;\n\tvar lmap, dmap;\n\t\n\twhile(BFINAL==0) {\t\t\n\t\tBFINAL = bitsF(data, pos  , 1);\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\n\t\t//console.log(BFINAL, BTYPE);\n\t\t\n\t\tif(BTYPE==0) {\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \n\t\t\tif(noBuf) buf=_check(buf, off+len);\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\n\t\t}\n\t\tif(noBuf) buf=_check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\n\t\tif(BTYPE==2) {\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\n\t\t\tvar tl = 1;\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\n\t\t\tmakeCodes(U.itree, tl);\n\t\t\tcodes2map(U.itree, tl, U.imap);\n\t\t\t\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\n\t\t\t\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\n\t\t\tvar mx0 = _copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\n\t\t\tvar mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\n\t\t\t\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\n\t\t\tmakeCodes(U.ltree, mx0);\n\t\t\tcodes2map(U.ltree, mx0, lmap);\n\t\t\t\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\n\t\t\tmakeCodes(U.dtree, mx1);\n\t\t\tcodes2map(U.dtree, mx1, dmap);\n\t\t}\n\t\t//var ooff=off, opos=pos;\n\t\twhile(true) {\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\n\t\t\telse if(lit==256) {  break;  }\n\t\t\telse {\n\t\t\t\tvar end = off+lit-254;\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\n\t\t\t\t//dst[end-off]++;\n\t\t\t\t\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\n\t\t\t\tvar dlit = dcode>>>4;\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\n\t\t\t\t\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\n\t\t\t\tif(noBuf) buf=_check(buf, off+(1<<17));\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \n\t\t\t\toff=end;\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\n\t\t\t}\n\t\t}\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\n\t}\n\t//console.log(dst);\n\t//console.log(tlen, dlen, off-tlen+tcnt);\n\treturn buf.length==off ? buf : buf.slice(0,off);\n}\nfunction _check(buf, len) {\n\tvar bl=buf.length;  if(len<=bl) return buf;\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\n\treturn nbuf;\n}\n\nfunction _decodeTiny(lmap, LL, len, data, pos, tree) {\n\tvar bitsE = _bitsE, get17 = _get17;\n\tvar i = 0;\n\twhile(i<len) {\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\n\t\tvar lit = code>>>4; \n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\n\t\telse {\n\t\t\tvar ll = 0, n = 0;\n\t\t\tif(lit==16) {\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\n\t\t\t}\n\t\t\telse if(lit==17) {\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\n\t\t\t}\n\t\t\telse if(lit==18) {\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\n\t\t\t}\n\t\t\tvar ni = i+n;\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\n\t\t}\n\t}\n\treturn pos;\n}\nfunction _copyOut(src, off, len, tree) {\n\tvar mx=0, i=0, tl=tree.length>>>1;\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\n\treturn mx;\n}\n\nfunction makeCodes(tree, MAX_BITS) {  // code, length\n\tvar max_code = tree.length;\n\tvar code, bits, n, i, len;\n\t\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\n\t\n\tvar next_code = U.next_code;\t// smallest code for each length\n\t\n\tcode = 0;\n\tbl_count[0] = 0;\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tcode = (code + bl_count[bits-1]) << 1;\n\t\tnext_code[bits] = code;\n\t}\n\t\n\tfor (n = 0; n < max_code; n+=2) {\n\t\tlen = tree[n+1];\n\t\tif (len != 0) {\n\t\t\ttree[n] = next_code[len];\n\t\t\tnext_code[len]++;\n\t\t}\n\t}\n}\nfunction codes2map(tree, MAX_BITS, map) {\n\tvar max_code = tree.length;\n\tvar r15 = U.rev15;\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\n\t\tvar lit = i>>1;\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\n\t\twhile(i0!=i1) {\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\n\t\t\tmap[p0]=val;  i0++;\n\t\t}\n\t}\n}\nfunction revCodes(tree, MAX_BITS) {\n\tvar r15 = U.rev15, imb = 15-MAX_BITS;\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\n}\n\nfunction _bitsE(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\nfunction _bitsF(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\n/*\nfunction _get9(dt, pos) {\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\n} */\nfunction _get17(dt, pos) {\t// return at least 17 meaningful bytes\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\n}\nconst U = function(){\n\tvar u16=Uint16Array, u32=Uint32Array;\n\treturn {\n\t\tnext_code : new u16(16),\n\t\tbl_count  : new u16(16),\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\n\t\tldef : new u16(32),\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\n\t\tddef : new u32(32),\n\t\tflmap: new u16(  512),  fltree: [],\n\t\tfdmap: new u16(   32),  fdtree: [],\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\n\t\tdmap : new u16(32768),  dtree : [],\n\t\timap : new u16(  512),  itree : [],\n\t\t//rev9 : new u16(  512)\n\t\trev15: new u16(1<<15),\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\n\t\tlits : new u32(15000),\n\t\tstrt : new u16(1<<16),\n\t\tprev : new u16(1<<15)\n\t};  \n} ();\n\n(function(){\t\n\tvar len = 1<<15;\n\tfor(var i=0; i<len; i++) {\n\t\tvar x = i;\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\n\t}\n\t\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\n\t\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\n\t\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\n\t/*\n\tvar i = 0;\n\tfor(; i<=143; i++) U.fltree.push(0,8);\n\tfor(; i<=255; i++) U.fltree.push(0,9);\n\tfor(; i<=279; i++) U.fltree.push(0,7);\n\tfor(; i<=287; i++) U.fltree.push(0,8);\n\t*/\n\tmakeCodes(U.fltree, 9);\n\tcodes2map(U.fltree, 9, U.flmap);\n\trevCodes (U.fltree, 9);\n\t\n\tpushV(U.fdtree,32,5);\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\n\tmakeCodes(U.fdtree, 5);\n\tcodes2map(U.fdtree, 5, U.fdmap);\n\trevCodes (U.fdtree, 5);\n\t\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\n\t/*\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\n\t*/\n})();\n\nconst crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n};\r\n\r\nfunction inflateRaw(file, buf) {  return inflate(file, buf);  }\n\n/* global module */\n\nconst config = {\n  numWorkers: 1,\n  workerURL: '',\n  useWorkers: false,\n};\n\nlet nextId = 0;\n\n// Requests are put on a queue.\n// We don't send the request to the worker until the worker\n// is finished. This probably adds a small amount of latency\n// but the issue is imagine you have 2 workers. You give worker\n// A x seconds of work to do and worker B y seconds of work to\n// do. You don't know which will finish first. If you give\n// the worker with more work to do the request then you'll\n// waste time.\n\n// note: we can't check `workers.length` for deciding if\n// we've reached `config.numWorkers` because creation the worker\n// is async which means other requests to make workers might\n// come in before a worker gets added to `workers`\nlet numWorkers = 0;\nlet canUseWorkers = true;   // gets set to false if we can't start a worker\nconst workers = [];\nconst availableWorkers = [];\nconst waitingForWorkerQueue = [];\nconst currentlyProcessingIdToRequestMap = new Map();\n\nfunction handleResult(e) {\n  makeWorkerAvailable(e.target);\n  const {id, error, data} = e.data;\n  const request = currentlyProcessingIdToRequestMap.get(id);\n  currentlyProcessingIdToRequestMap.delete(id);\n  if (error) {\n    request.reject(error);\n  } else {\n    request.resolve(data);\n  }\n}\n\n// Because Firefox uses non-standard onerror to signal an error.\nfunction startWorker(url) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n    worker.onmessage = (e) => {\n      if (e.data === 'start') {\n        worker.onerror = undefined;\n        worker.onmessage = undefined;\n        resolve(worker);\n      } else {\n        reject(new Error(`unexpected message: ${e.data}`));\n      }\n    };\n    worker.onerror = reject;\n  });\n}\n\nfunction dynamicRequire(mod, request) {\n  return mod.require ? mod.require(request) : {};\n}\n\nconst workerHelper = (function() {\n  if (isNode) {\n    // We need to use `dynamicRequire` because `require` on it's own will be optimized by webpack.\n    const {Worker} = dynamicRequire(module, 'worker_threads');\n    return {\n      async createWorker(url) {\n        return new Worker(url);\n      },\n      addEventListener(worker, fn) {\n        worker.on('message', (data) => {\n          fn({target: worker, data});\n        });\n      },\n      async terminate(worker) {\n        await worker.terminate();\n      },\n    };\n  } else {\n    return {\n      async createWorker(url) {\n        // I don't understand this security issue\n        // Apparently there is some iframe setting or http header\n        // that prevents cross domain workers. But, I can manually\n        // download the text and do it. I reported this to Chrome\n        // and they said it was fine so ¯\\_(ツ)_/¯\n        try {\n          const worker = await startWorker(url);\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker:', url);\n        }\n\n        let text;\n        try {\n          const req = await fetch(url, {mode: 'cors'});\n          if (!req.ok) {\n            throw new Error(`could not load: ${url}`);\n          }\n          text = await req.text();\n          url = URL.createObjectURL(new Blob([text], {type: 'application/javascript'}));\n          const worker = await startWorker(url);\n          config.workerURL = url;  // this is a hack. What's a better way to structure this code?\n          return worker;\n        } catch (e) {\n          console.warn('could not load worker via fetch:', url);\n        }\n\n        if (text !== undefined) {\n          try {\n            url = `data:application/javascript;base64,${btoa(text)}`;\n            const worker = await startWorker(url);\n            config.workerURL = url;\n            return worker;\n          } catch (e) {\n            console.warn('could not load worker via dataURI');\n          }\n        }\n\n        console.warn('workers will not be used');\n        throw new Error('can not start workers');\n      },\n      addEventListener(worker, fn) {\n        worker.addEventListener('message', fn);\n      },\n      async terminate(worker) {\n        worker.terminate();\n      },\n    };\n  }\n}());\n\nfunction makeWorkerAvailable(worker) {\n  availableWorkers.push(worker);\n  processWaitingForWorkerQueue();\n}\n\nasync function getAvailableWorker() {\n  if (availableWorkers.length === 0 && numWorkers < config.numWorkers) {\n    ++numWorkers;  // see comment at numWorkers declaration\n    try {\n      const worker = await workerHelper.createWorker(config.workerURL);\n      workers.push(worker);\n      availableWorkers.push(worker);\n      workerHelper.addEventListener(worker, handleResult);\n    } catch (e) {\n      // set this global out-of-band (needs refactor)\n      canUseWorkers = false;\n    }\n  }\n  return availableWorkers.pop();\n}\n\n// @param {Uint8Array} src\n// @param {number} uncompressedSize\n// @param {string} [type] mime-type\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawLocal(src, uncompressedSize, type, resolve) {\n  const dst = new Uint8Array(uncompressedSize);\n  inflateRaw(src, dst);\n  resolve(type\n     ? new Blob([dst], {type})\n     : dst.buffer);\n}\n\nasync function processWaitingForWorkerQueue() {\n  if (waitingForWorkerQueue.length === 0) {\n    return;\n  }\n\n  if (config.useWorkers && canUseWorkers) {\n    const worker = await getAvailableWorker();\n    // canUseWorkers might have been set out-of-band (need refactor)\n    if (canUseWorkers) {\n      if (worker) {\n        if (waitingForWorkerQueue.length === 0) {\n          // the queue might be empty while we awaited for a worker.\n          makeWorkerAvailable(worker);\n          return;\n        }\n        const {id, src, uncompressedSize, type, resolve, reject} = waitingForWorkerQueue.shift();\n        currentlyProcessingIdToRequestMap.set(id, {id, resolve, reject});\n        const transferables = [];\n        // NOTE: Originally I thought you could transfer an ArrayBuffer.\n        // The code on this side is often using views into the entire file\n        // which means if we transferred we'd lose the entire file. That sucks\n        // because it means there's an expensive copy to send the uncompressed\n        // data to the worker.\n        //\n        // Also originally I thought we could send a Blob but we'd need to refactor\n        // the code in unzipit/readEntryData as currently it reads the uncompressed\n        // bytes.\n        //\n        //if (!isBlob(src) && !isSharedArrayBuffer(src)) {\n        //  transferables.push(src);\n        //}\n        worker.postMessage({\n          type: 'inflate',\n          data: {\n            id,\n            type,\n            src,\n            uncompressedSize,\n          },\n        }, transferables);\n      }\n      return;\n    }\n  }\n\n  // inflate locally\n  // We loop here because what happens if many requests happen at once\n  // the first N requests will try to async make a worker. Other requests\n  // will then be on the queue. But if we fail to make workers then there\n  // are pending requests.\n  while (waitingForWorkerQueue.length) {\n    const {src, uncompressedSize, type, resolve} = waitingForWorkerQueue.shift();\n    let data = src;\n    if (isBlob(src)) {\n      data = await readBlobAsUint8Array(src);\n    }\n    inflateRawLocal(data, uncompressedSize, type, resolve);\n  }\n}\n\nfunction setOptions(options) {\n  config.workerURL = options.workerURL || config.workerURL;\n  // there's no reason to set the workerURL if you're not going to use workers\n  if (options.workerURL) {\n    config.useWorkers = true;\n  }\n  config.useWorkers = options.useWorkers !== undefined ? options.useWorkers : config.useWorkers;\n  config.numWorkers = options.numWorkers || config.numWorkers;\n}\n\n// It has to take non-zero time to put a large typed array in a Blob since the very\n// next instruction you could change the contents of the array. So, if you're reading\n// the zip file for images/video/audio then all you want is a Blob on which to get a URL.\n// so that operation of putting the data in a Blob should happen in the worker.\n//\n// Conversely if you want the data itself then you want an ArrayBuffer immediately\n// since the worker can transfer its ArrayBuffer zero copy.\n//\n// @param {Uint8Array|Blob} src\n// @param {number} uncompressedSize\n// @param {string} [type] falsy or mimeType string (eg: 'image/png')\n// @returns {ArrayBuffer|Blob} ArrayBuffer if type is falsy or Blob otherwise.\nfunction inflateRawAsync(src, uncompressedSize, type) {\n  return new Promise((resolve, reject) => {\n    // note: there is potential an expensive copy here. In order for the data\n    // to make it into the worker we need to copy the data to the worker unless\n    // it's a Blob or a SharedArrayBuffer.\n    //\n    // Solutions:\n    //\n    // 1. A minor enhancement, if `uncompressedSize` is small don't call the worker.\n    //\n    //    might be a win period as their is overhead calling the worker\n    //\n    // 2. Move the entire library to the worker\n    //\n    //    Good, Maybe faster if you pass a URL, Blob, or SharedArrayBuffer? Not sure about that\n    //    as those are also easy to transfer. Still slow if you pass an ArrayBuffer\n    //    as the ArrayBuffer has to be copied to the worker.\n    //\n    // I guess benchmarking is really the only thing to try.\n    waitingForWorkerQueue.push({src, uncompressedSize, type, resolve, reject, id: nextId++});\n    processWaitingForWorkerQueue();\n  });\n}\n\nfunction clearArray(arr) {\n  arr.splice(0, arr.length);\n}\n\nasync function cleanup() {\n  for (const worker of workers) {\n    await workerHelper.terminate(worker);\n  }\n  clearArray(workers);\n  clearArray(availableWorkers);\n  clearArray(waitingForWorkerQueue);\n  currentlyProcessingIdToRequestMap.clear();\n  numWorkers = 0;\n  canUseWorkers = true;\n}\n\n/*\nclass Zip {\n  constructor(reader) {\n    comment,  // the comment for this entry\n    commentBytes, // the raw comment for this entry\n  }\n}\n*/\n\nfunction dosDateTimeToDate(date, time) {\n  const day = date & 0x1f; // 1-31\n  const month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  const year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  const millisecond = 0;\n  const second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  const minute = time >> 5 & 0x3f; // 0-59\n  const hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nclass ZipEntry {\n  constructor(reader, rawEntry) {\n    this._reader = reader;\n    this._rawEntry = rawEntry;\n    this.name = rawEntry.name;\n    this.nameBytes = rawEntry.nameBytes;\n    this.size = rawEntry.uncompressedSize;\n    this.compressedSize = rawEntry.compressedSize;\n    this.comment = rawEntry.comment;\n    this.commentBytes = rawEntry.commentBytes;\n    this.compressionMethod = rawEntry.compressionMethod;\n    this.lastModDate = dosDateTimeToDate(rawEntry.lastModFileDate, rawEntry.lastModFileTime);\n    this.isDirectory = rawEntry.uncompressedSize === 0 && rawEntry.name.endsWith('/');\n    this.encrypted = !!(rawEntry.generalPurposeBitFlag & 0x1);\n    this.externalFileAttributes = rawEntry.externalFileAttributes;\n    this.versionMadeBy = rawEntry.versionMadeBy;\n  }\n  // returns a promise that returns a Blob for this entry\n  async blob(type = 'application/octet-stream') {\n    return await readEntryDataAsBlob(this._reader, this._rawEntry, type);\n  }\n  // returns a promise that returns an ArrayBuffer for this entry\n  async arrayBuffer() {\n    return await readEntryDataAsArrayBuffer(this._reader, this._rawEntry);\n  }\n  // returns text, assumes the text is valid utf8. If you want more options decode arrayBuffer yourself\n  async text() {\n    const buffer = await this.arrayBuffer();\n    return decodeBuffer(new Uint8Array(buffer));\n  }\n  // returns text with JSON.parse called on it. If you want more options decode arrayBuffer yourself\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n}\n\nconst EOCDR_WITHOUT_COMMENT_SIZE = 22;\nconst MAX_COMMENT_SIZE = 0xffff; // 2-byte size\nconst EOCDR_SIGNATURE = 0x06054b50;\nconst ZIP64_EOCDR_SIGNATURE = 0x06064b50;\n\nasync function readAs(reader, offset, length) {\n  return await reader.read(offset, length);\n}\n\n// The point of this function is we want to be able to pass the data\n// to a worker as fast as possible so when decompressing if the data\n// is already a blob and we can get a blob then get a blob.\n//\n// I'm not sure what a better way to refactor this is. We've got examples\n// of multiple readers. Ideally, for every type of reader we could ask\n// it, \"give me a type that is zero copy both locally and when sent to a worker\".\n//\n// The problem is the worker would also have to know the how to handle this\n// opaque type. I suppose the correct solution is to register different\n// reader handlers in the worker so BlobReader would register some\n// `handleZeroCopyType<BlobReader>`. At the moment I don't feel like\n// refactoring. As it is you just pass in an instance of the reader\n// but instead you'd have to register the reader and some how get the\n// source for the `handleZeroCopyType` handler function into the worker.\n// That sounds like a huge PITA, requiring you to put the implementation\n// in a separate file so the worker can load it or some other workaround\n// hack.\n//\n// For now this hack works even if it's not generic.\nasync function readAsBlobOrTypedArray(reader, offset, length, type) {\n  if (reader.sliceAsBlob) {\n    return await reader.sliceAsBlob(offset, length, type);\n  }\n  return await reader.read(offset, length);\n}\n\nconst crc$1 = {\n  unsigned() {\n    return 0;\n  },\n};\n\nfunction getUint16LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100;\n}\n\nfunction getUint32LE(uint8View, offset) {\n  return uint8View[offset    ] +\n         uint8View[offset + 1] * 0x100 +\n         uint8View[offset + 2] * 0x10000 +\n         uint8View[offset + 3] * 0x1000000;\n}\n\nfunction getUint64LE(uint8View, offset) {\n  return getUint32LE(uint8View, offset) +\n         getUint32LE(uint8View, offset + 4) * 0x100000000;\n}\n\n/* eslint-disable no-irregular-whitespace */\n// const decodeCP437 = (function() {\n//   const cp437 = '\\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';\n//\n//   return function(uint8view) {\n//     return Array.from(uint8view).map(v => cp437[v]).join('');\n//   };\n// }());\n/* eslint-enable no-irregular-whitespace */\n\nconst utf8Decoder = new TextDecoder();\nfunction decodeBuffer(uint8View, isUTF8) {  /* eslint-disable-line no-unused-vars */ /* lgtm [js/superfluous-trailing-arguments] */\n  if (isSharedArrayBuffer(uint8View.buffer)) {\n    uint8View = new Uint8Array(uint8View);\n  }\n  return utf8Decoder.decode(uint8View);\n  /*\n  AFAICT the UTF8 flat is not set so it's 100% up to the user\n  to self decode if their file is not utf8 filenames\n  return isUTF8\n      ? utf8Decoder.decode(uint8View)\n      : decodeCP437(uint8View);\n  */\n}\n\nasync function findEndOfCentralDirector(reader, totalLength) {\n  const size = Math.min(EOCDR_WITHOUT_COMMENT_SIZE + MAX_COMMENT_SIZE, totalLength);\n  const readStart = totalLength - size;\n  const data = await readAs(reader, readStart, size);\n  for (let i = size - EOCDR_WITHOUT_COMMENT_SIZE; i >= 0; --i) {\n    if (getUint32LE(data, i) !== EOCDR_SIGNATURE) {\n      continue;\n    }\n\n    // 0 - End of central directory signature\n    const eocdr = new Uint8Array(data.buffer, data.byteOffset + i, data.byteLength - i);\n    // 4 - Number of this disk\n    const diskNumber = getUint16LE(eocdr, 4);\n    if (diskNumber !== 0) {\n      throw new Error(`multi-volume zip files are not supported. This is volume: ${diskNumber}`);\n    }\n\n    // 6 - Disk where central directory starts\n    // 8 - Number of central directory records on this disk\n    // 10 - Total number of central directory records\n    const entryCount = getUint16LE(eocdr, 10);\n    // 12 - Size of central directory (bytes)\n    const centralDirectorySize = getUint32LE(eocdr, 12);\n    // 16 - Offset of start of central directory, relative to start of archive\n    const centralDirectoryOffset = getUint32LE(eocdr, 16);\n    // 20 - Comment length\n    const commentLength = getUint16LE(eocdr, 20);\n    const expectedCommentLength = eocdr.length - EOCDR_WITHOUT_COMMENT_SIZE;\n    if (commentLength !== expectedCommentLength) {\n      throw new Error(`invalid comment length. expected: ${expectedCommentLength}, actual: ${commentLength}`);\n    }\n\n    // 22 - Comment\n    // the encoding is always cp437.\n    const commentBytes = new Uint8Array(eocdr.buffer, eocdr.byteOffset + 22, commentLength);\n    const comment = decodeBuffer(commentBytes);\n\n    if (entryCount === 0xffff || centralDirectoryOffset === 0xffffffff) {\n      return await readZip64CentralDirectory(reader, readStart + i, comment, commentBytes);\n    } else {\n      return await readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n    }\n  }\n\n  throw new Error('could not find end of central directory. maybe not zip file');\n}\n\nconst END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE = 0x07064b50;\n\nasync function readZip64CentralDirectory(reader, offset, comment, commentBytes) {\n  // ZIP64 Zip64 end of central directory locator\n  const zip64EocdlOffset = offset - 20;\n  const eocdl = await readAs(reader, zip64EocdlOffset, 20);\n\n  // 0 - zip64 end of central dir locator signature\n  if (getUint32LE(eocdl, 0) !== END_OF_CENTRAL_DIRECTORY_LOCATOR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory locator signature');\n  }\n\n  // 4 - number of the disk with the start of the zip64 end of central directory\n  // 8 - relative offset of the zip64 end of central directory record\n  const zip64EocdrOffset = getUint64LE(eocdl, 8);\n  // 16 - total number of disks\n\n  // ZIP64 end of central directory record\n  const zip64Eocdr = await readAs(reader, zip64EocdrOffset, 56);\n\n  // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n  if (getUint32LE(zip64Eocdr, 0) !== ZIP64_EOCDR_SIGNATURE) {\n    throw new Error('invalid zip64 end of central directory record signature');\n  }\n  // 4 - size of zip64 end of central directory record                8 bytes\n  // 12 - version made by                                             2 bytes\n  // 14 - version needed to extract                                   2 bytes\n  // 16 - number of this disk                                         4 bytes\n  // 20 - number of the disk with the start of the central directory  4 bytes\n  // 24 - total number of entries in the central directory on this disk         8 bytes\n  // 32 - total number of entries in the central directory            8 bytes\n  const entryCount = getUint64LE(zip64Eocdr, 32);\n  // 40 - size of the central directory                               8 bytes\n  const centralDirectorySize = getUint64LE(zip64Eocdr, 40);\n  // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n  const centralDirectoryOffset = getUint64LE(zip64Eocdr, 48);\n  // 56 - zip64 extensible data sector                                (variable size)\n  return readEntries(reader, centralDirectoryOffset, centralDirectorySize, entryCount, comment, commentBytes);\n}\n\nconst CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE = 0x02014b50;\n\nasync function readEntries(reader, centralDirectoryOffset, centralDirectorySize, rawEntryCount, comment, commentBytes) {\n  let readEntryCursor = 0;\n  const allEntriesBuffer = await readAs(reader, centralDirectoryOffset, centralDirectorySize);\n  const rawEntries = [];\n\n  for (let e = 0; e < rawEntryCount; ++e) {\n    const buffer = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + 46);\n    // 0 - Central directory file header signature\n    const signature = getUint32LE(buffer, 0);\n    if (signature !== CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE) {\n      throw new Error(`invalid central directory file header signature: 0x${signature.toString(16)}`);\n    }\n    const rawEntry = {\n      // 4 - Version made by\n      versionMadeBy: getUint16LE(buffer, 4),\n      // 6 - Version needed to extract (minimum)\n      versionNeededToExtract: getUint16LE(buffer, 6),\n      // 8 - General purpose bit flag\n      generalPurposeBitFlag: getUint16LE(buffer, 8),\n      // 10 - Compression method\n      compressionMethod: getUint16LE(buffer, 10),\n      // 12 - File last modification time\n      lastModFileTime: getUint16LE(buffer, 12),\n      // 14 - File last modification date\n      lastModFileDate: getUint16LE(buffer, 14),\n      // 16 - CRC-32\n      crc32: getUint32LE(buffer, 16),\n      // 20 - Compressed size\n      compressedSize: getUint32LE(buffer, 20),\n      // 24 - Uncompressed size\n      uncompressedSize: getUint32LE(buffer, 24),\n      // 28 - File name length (n)\n      fileNameLength: getUint16LE(buffer, 28),\n      // 30 - Extra field length (m)\n      extraFieldLength: getUint16LE(buffer, 30),\n      // 32 - File comment length (k)\n      fileCommentLength: getUint16LE(buffer, 32),\n      // 34 - Disk number where file starts\n      // 36 - Internal file attributes\n      internalFileAttributes: getUint16LE(buffer, 36),\n      // 38 - External file attributes\n      externalFileAttributes: getUint32LE(buffer, 38),\n      // 42 - Relative offset of local file header\n      relativeOffsetOfLocalHeader: getUint32LE(buffer, 42),\n    };\n\n    if (rawEntry.generalPurposeBitFlag & 0x40) {\n      throw new Error('strong encryption is not supported');\n    }\n\n    readEntryCursor += 46;\n\n    const data = allEntriesBuffer.subarray(readEntryCursor, readEntryCursor + rawEntry.fileNameLength + rawEntry.extraFieldLength + rawEntry.fileCommentLength);\n    rawEntry.nameBytes = data.slice(0, rawEntry.fileNameLength);\n    rawEntry.name = decodeBuffer(rawEntry.nameBytes);\n\n    // 46+n - Extra field\n    const fileCommentStart = rawEntry.fileNameLength + rawEntry.extraFieldLength;\n    const extraFieldBuffer = data.slice(rawEntry.fileNameLength, fileCommentStart);\n    rawEntry.extraFields = [];\n    let i = 0;\n    while (i < extraFieldBuffer.length - 3) {\n      const headerId = getUint16LE(extraFieldBuffer, i + 0);\n      const dataSize = getUint16LE(extraFieldBuffer, i + 2);\n      const dataStart = i + 4;\n      const dataEnd = dataStart + dataSize;\n      if (dataEnd > extraFieldBuffer.length) {\n        throw new Error('extra field length exceeds extra field buffer size');\n      }\n      rawEntry.extraFields.push({\n        id: headerId,\n        data: extraFieldBuffer.slice(dataStart, dataEnd),\n      });\n      i = dataEnd;\n    }\n\n    // 46+n+m - File comment\n    rawEntry.commentBytes = data.slice(fileCommentStart, fileCommentStart + rawEntry.fileCommentLength);\n    rawEntry.comment = decodeBuffer(rawEntry.commentBytes);\n\n    readEntryCursor += data.length;\n\n    if (rawEntry.uncompressedSize            === 0xffffffff ||\n        rawEntry.compressedSize              === 0xffffffff ||\n        rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n      // ZIP64 format\n      // find the Zip64 Extended Information Extra Field\n      const zip64ExtraField = rawEntry.extraFields.find(e => e.id === 0x0001);\n      if (!zip64ExtraField) {\n        throw new Error('expected zip64 extended information extra field');\n      }\n      const zip64EiefBuffer = zip64ExtraField.data;\n      let index = 0;\n      // 0 - Original Size          8 bytes\n      if (rawEntry.uncompressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include uncompressed size');\n        }\n        rawEntry.uncompressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 8 - Compressed Size        8 bytes\n      if (rawEntry.compressedSize === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include compressed size');\n        }\n        rawEntry.compressedSize = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 16 - Relative Header Offset 8 bytes\n      if (rawEntry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        if (index + 8 > zip64EiefBuffer.length) {\n          throw new Error('zip64 extended information extra field does not include relative header offset');\n        }\n        rawEntry.relativeOffsetOfLocalHeader = getUint64LE(zip64EiefBuffer, index);\n        index += 8;\n      }\n      // 24 - Disk Start Number      4 bytes\n    }\n\n    // check for Info-ZIP Unicode Path Extra Field (0x7075)\n    // see https://github.com/thejoshwolfe/yauzl/issues/33\n    const nameField = rawEntry.extraFields.find(e =>\n        e.id === 0x7075 &&\n        e.data.length >= 6 && // too short to be meaningful\n        e.data[0] === 1 &&    // Version       1 byte      version of this extra field, currently 1\n        getUint32LE(e.data, 1), crc$1.unsigned(rawEntry.nameBytes)); // NameCRC32     4 bytes     File Name Field CRC32 Checksum\n                                                                   // > If the CRC check fails, this UTF-8 Path Extra Field should be\n                                                                   // > ignored and the File Name field in the header should be used instead.\n    if (nameField) {\n        // UnicodeName Variable UTF-8 version of the entry File Name\n        rawEntry.fileName = decodeBuffer(nameField.data.slice(5));\n    }\n\n    // validate file size\n    if (rawEntry.compressionMethod === 0) {\n      let expectedCompressedSize = rawEntry.uncompressedSize;\n      if ((rawEntry.generalPurposeBitFlag & 0x1) !== 0) {\n        // traditional encryption prefixes the file data with a header\n        expectedCompressedSize += 12;\n      }\n      if (rawEntry.compressedSize !== expectedCompressedSize) {\n        throw new Error(`compressed size mismatch for stored file: ${rawEntry.compressedSize} != ${expectedCompressedSize}`);\n      }\n    }\n    rawEntries.push(rawEntry);\n  }\n  const zip = {\n    comment,\n    commentBytes,\n  };\n  return {\n    zip,\n    entries: rawEntries.map(e => new ZipEntry(reader, e)),\n  };\n}\n\nasync function readEntryDataHeader(reader, rawEntry) {\n  if (rawEntry.generalPurposeBitFlag & 0x1) {\n    throw new Error('encrypted entries not supported');\n  }\n  const buffer = await readAs(reader, rawEntry.relativeOffsetOfLocalHeader, 30);\n  // note: maybe this should be passed in or cached on entry\n  // as it's async so there will be at least one tick (not sure about that)\n  const totalLength = await reader.getLength();\n\n  // 0 - Local file header signature = 0x04034b50\n  const signature = getUint32LE(buffer, 0);\n  if (signature !== 0x04034b50) {\n    throw new Error(`invalid local file header signature: 0x${signature.toString(16)}`);\n  }\n\n  // all this should be redundant\n  // 4 - Version needed to extract (minimum)\n  // 6 - General purpose bit flag\n  // 8 - Compression method\n  // 10 - File last modification time\n  // 12 - File last modification date\n  // 14 - CRC-32\n  // 18 - Compressed size\n  // 22 - Uncompressed size\n  // 26 - File name length (n)\n  const fileNameLength = getUint16LE(buffer, 26);\n  // 28 - Extra field length (m)\n  const extraFieldLength = getUint16LE(buffer, 28);\n  // 30 - File name\n  // 30+n - Extra field\n  const localFileHeaderEnd = rawEntry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n  let decompress;\n  if (rawEntry.compressionMethod === 0) {\n    // 0 - The file is stored (no compression)\n    decompress = false;\n  } else if (rawEntry.compressionMethod === 8) {\n    // 8 - The file is Deflated\n    decompress = true;\n  } else {\n    throw new Error(`unsupported compression method: ${rawEntry.compressionMethod}`);\n  }\n  const fileDataStart = localFileHeaderEnd;\n  const fileDataEnd = fileDataStart + rawEntry.compressedSize;\n  if (rawEntry.compressedSize !== 0) {\n    // bounds check now, because the read streams will probably not complain loud enough.\n    // since we're dealing with an unsigned offset plus an unsigned size,\n    // we only have 1 thing to check for.\n    if (fileDataEnd > totalLength) {\n      throw new Error(`file data overflows file bounds: ${fileDataStart} +  ${rawEntry.compressedSize}  > ${totalLength}`);\n    }\n  }\n  return {\n    decompress,\n    fileDataStart,\n  };\n}\n\nasync function readEntryDataAsArrayBuffer(reader, rawEntry) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const dataView = await readAs(reader, fileDataStart, rawEntry.compressedSize);\n    // make copy?\n    //\n    // 1. The source is a Blob/file. In this case we'll get back TypedArray we can just hand to the user\n    // 2. The source is a TypedArray. In this case we'll get back TypedArray that is a view into a larger buffer\n    //    but because ultimately this is used to return an ArrayBuffer to `someEntry.arrayBuffer()`\n    //    we need to return copy since we need the `ArrayBuffer`, not the TypedArray to exactly match the data.\n    //    Note: We could add another API function `bytes()` or something that returned a `Uint8Array`\n    //    instead of an `ArrayBuffer`. This would let us skip a copy here. But this case only happens for uncompressed\n    //    data. That seems like a rare enough case that adding a new API is not worth it? Or is it? A zip of jpegs or mp3s\n    //    might not be compressed. For now that's a TBD.\n    return isTypedArraySameAsArrayBuffer(dataView) ? dataView.buffer : dataView.slice().buffer;\n  }\n  // see comment in readEntryDateAsBlob\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize);\n  return result;\n}\n\nasync function readEntryDataAsBlob(reader, rawEntry, type) {\n  const {decompress, fileDataStart} = await readEntryDataHeader(reader, rawEntry);\n  if (!decompress) {\n    const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize, type);\n    if (isBlob(typedArrayOrBlob)) {\n      return typedArrayOrBlob;\n    }\n    return new Blob([isSharedArrayBuffer(typedArrayOrBlob.buffer) ? new Uint8Array(typedArrayOrBlob) : typedArrayOrBlob], {type});\n  }\n  // Here's the issue with this mess (should refactor?)\n  // if the source is a blob then we really want to pass a blob to inflateRawAsync to avoid a large\n  // copy if we're going to a worker.\n  const typedArrayOrBlob = await readAsBlobOrTypedArray(reader, fileDataStart, rawEntry.compressedSize);\n  const result = await inflateRawAsync(typedArrayOrBlob, rawEntry.uncompressedSize, type);\n  return result;\n}\n\nfunction setOptions$1(options) {\n  setOptions(options);\n}\n\nasync function unzipRaw(source) {\n  let reader;\n  if (typeof Blob !== 'undefined' && source instanceof Blob) {\n    reader = new BlobReader(source);\n  } else if (source instanceof ArrayBuffer || (source && source.buffer && source.buffer instanceof ArrayBuffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (isSharedArrayBuffer(source) || isSharedArrayBuffer(source.buffer)) {\n    reader = new ArrayBufferReader(source);\n  } else if (typeof source === 'string') {\n    const req = await fetch(source);\n    if (!req.ok) {\n      throw new Error(`failed http request ${source}, status: ${req.status}: ${req.statusText}`);\n    }\n    const blob = await req.blob();\n    reader = new BlobReader(blob);\n  } else if (typeof source.getLength === 'function' && typeof source.read === 'function') {\n    reader = source;\n  } else {\n    throw new Error('unsupported source type');\n  }\n\n  const totalLength = await reader.getLength();\n\n  if (totalLength > Number.MAX_SAFE_INTEGER) {\n    throw new Error(`file too large. size: ${totalLength}. Only file sizes up 4503599627370496 bytes are supported`);\n  }\n\n  return await findEndOfCentralDirector(reader, totalLength);\n}\n\n// If the names are not utf8 you should use unzipitRaw\nasync function unzip(source) {\n  const {zip, entries} = await unzipRaw(source);\n  return {\n    zip,\n    entries: Object.fromEntries(entries.map(v => [v.name, v])),\n  };\n}\n\nfunction cleanup$1() {\n  cleanup();\n}\n\nexport { HTTPRangeReader, cleanup$1 as cleanup, setOptions$1 as setOptions, unzip, unzipRaw };\n"],
  "mappings": "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",
  "names": ["Worker", "e", "typedArrayOrBlob"]
}
