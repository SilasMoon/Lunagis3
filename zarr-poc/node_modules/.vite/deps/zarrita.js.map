{
  "version": 3,
  "sources": ["../../zarrita/dist/src/errors.js", "../../zarrita/dist/src/typedarray.js", "../../zarrita/dist/src/util.js", "../../zarrita/dist/src/codecs/bitround.js", "../../zarrita/dist/src/codecs/bytes.js", "../../zarrita/dist/src/codecs/crc32c.js", "../../zarrita/dist/src/codecs/json2.js", "../../zarrita/dist/src/codecs/transpose.js", "../../zarrita/dist/src/codecs/vlen-utf8.js", "../../zarrita/dist/src/codecs.js", "../../zarrita/dist/src/codecs/sharding.js", "../../zarrita/dist/src/hierarchy.js", "../../zarrita/dist/src/open.js", "../../zarrita/dist/src/create.js", "../../zarrita/dist/src/indexing/util.js", "../../zarrita/dist/src/indexing/indexer.js", "../../zarrita/dist/src/indexing/get.js", "../../zarrita/dist/src/indexing/set.js", "../../zarrita/dist/src/indexing/ops.js", "../../zarrita/dist/src/consolidated.js", "../../@zarrita/storage/src/util.ts", "../../@zarrita/storage/src/fetch.ts"],
  "sourcesContent": ["export class NodeNotFoundError extends Error {\n    constructor(context, options = {}) {\n        super(`Node not found: ${context}`, options);\n        this.name = \"NodeNotFoundError\";\n    }\n}\nexport class KeyError extends Error {\n    constructor(path) {\n        super(`Missing key: ${path}`);\n        this.name = \"KeyError\";\n    }\n}\n", "/**\n * Custom array-like views (i.e., TypedArrays) for Zarr binary data buffers.\n *\n * @module\n */\n/**\n * An array-like view of a fixed-length boolean buffer.\n *\n * Encoded as 1 byte per value.\n */\nexport class BoolArray {\n    #bytes;\n    constructor(x, byteOffset, length) {\n        if (typeof x === \"number\") {\n            this.#bytes = new Uint8Array(x);\n        }\n        else if (x instanceof ArrayBuffer) {\n            this.#bytes = new Uint8Array(x, byteOffset, length);\n        }\n        else {\n            this.#bytes = new Uint8Array(Array.from(x, (v) => (v ? 1 : 0)));\n        }\n    }\n    get BYTES_PER_ELEMENT() {\n        return 1;\n    }\n    get byteOffset() {\n        return this.#bytes.byteOffset;\n    }\n    get byteLength() {\n        return this.#bytes.byteLength;\n    }\n    get buffer() {\n        return this.#bytes.buffer;\n    }\n    get length() {\n        return this.#bytes.length;\n    }\n    get(idx) {\n        let value = this.#bytes[idx];\n        return typeof value === \"number\" ? value !== 0 : value;\n    }\n    set(idx, value) {\n        this.#bytes[idx] = value ? 1 : 0;\n    }\n    fill(value) {\n        this.#bytes.fill(value ? 1 : 0);\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++) {\n            yield this.get(i);\n        }\n    }\n}\n/**\n * An array-like view of a fixed-length byte buffer.\n *\n * Encodes a raw byte sequences without enforced encoding.\n */\nexport class ByteStringArray {\n    _data;\n    chars;\n    #encoder;\n    constructor(chars, x, byteOffset, length) {\n        this.chars = chars;\n        this.#encoder = new TextEncoder();\n        if (typeof x === \"number\") {\n            this._data = new Uint8Array(x * chars);\n        }\n        else if (x instanceof ArrayBuffer) {\n            if (length)\n                length = length * chars;\n            this._data = new Uint8Array(x, byteOffset, length);\n        }\n        else {\n            let values = Array.from(x);\n            this._data = new Uint8Array(values.length * chars);\n            for (let i = 0; i < values.length; i++) {\n                this.set(i, values[i]);\n            }\n        }\n    }\n    get BYTES_PER_ELEMENT() {\n        return this.chars;\n    }\n    get byteOffset() {\n        return this._data.byteOffset;\n    }\n    get byteLength() {\n        return this._data.byteLength;\n    }\n    get buffer() {\n        return this._data.buffer;\n    }\n    get length() {\n        return this.byteLength / this.BYTES_PER_ELEMENT;\n    }\n    get(idx) {\n        const view = new Uint8Array(this.buffer, this.byteOffset + this.chars * idx, this.chars);\n        // biome-ignore lint/suspicious/noControlCharactersInRegex: necessary for null byte removal\n        return new TextDecoder().decode(view).replace(/\\x00/g, \"\");\n    }\n    set(idx, value) {\n        const view = new Uint8Array(this.buffer, this.byteOffset + this.chars * idx, this.chars);\n        view.fill(0); // clear current\n        view.set(this.#encoder.encode(value));\n    }\n    fill(value) {\n        const encoded = this.#encoder.encode(value);\n        for (let i = 0; i < this.length; i++) {\n            this._data.set(encoded, i * this.chars);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++) {\n            yield this.get(i);\n        }\n    }\n}\n/**\n * An array-like view of a fixed-length Unicode string buffer.\n *\n * Encoded as UTF-32 code points.\n */\nexport class UnicodeStringArray {\n    #data;\n    chars;\n    constructor(chars, x, byteOffset, length) {\n        this.chars = chars;\n        if (typeof x === \"number\") {\n            this.#data = new Int32Array(x * chars);\n        }\n        else if (x instanceof ArrayBuffer) {\n            if (length)\n                length *= chars;\n            this.#data = new Int32Array(x, byteOffset, length);\n        }\n        else {\n            const values = x;\n            const d = new UnicodeStringArray(chars, 1);\n            this.#data = new Int32Array((function* () {\n                for (let str of values) {\n                    d.set(0, str);\n                    yield* d.#data;\n                }\n            })());\n        }\n    }\n    get BYTES_PER_ELEMENT() {\n        return this.#data.BYTES_PER_ELEMENT * this.chars;\n    }\n    get byteLength() {\n        return this.#data.byteLength;\n    }\n    get byteOffset() {\n        return this.#data.byteOffset;\n    }\n    get buffer() {\n        return this.#data.buffer;\n    }\n    get length() {\n        return this.#data.length / this.chars;\n    }\n    get(idx) {\n        const offset = this.chars * idx;\n        let result = \"\";\n        for (let i = 0; i < this.chars; i++) {\n            result += String.fromCodePoint(this.#data[offset + i]);\n        }\n        // biome-ignore lint/suspicious/noControlCharactersInRegex: necessary for null byte removal\n        return result.replace(/\\u0000/g, \"\");\n    }\n    set(idx, value) {\n        const offset = this.chars * idx;\n        const view = this.#data.subarray(offset, offset + this.chars);\n        view.fill(0); // clear current\n        for (let i = 0; i < this.chars; i++) {\n            view[i] = value.codePointAt(i) ?? 0;\n        }\n    }\n    fill(value) {\n        // encode once\n        this.set(0, value);\n        // copy the encoded values to all other elements\n        let encoded = this.#data.subarray(0, this.chars);\n        for (let i = 1; i < this.length; i++) {\n            this.#data.set(encoded, i * this.chars);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let i = 0; i < this.length; i++) {\n            yield this.get(i);\n        }\n    }\n}\n", "import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"./typedarray.js\";\nexport function json_encode_object(o) {\n    const str = JSON.stringify(o, null, 2);\n    return new TextEncoder().encode(str);\n}\nexport function json_decode_object(bytes) {\n    const str = new TextDecoder().decode(bytes);\n    return JSON.parse(str);\n}\nexport function byteswap_inplace(view, bytes_per_element) {\n    const numFlips = bytes_per_element / 2;\n    const endByteIndex = bytes_per_element - 1;\n    let t = 0;\n    for (let i = 0; i < view.length; i += bytes_per_element) {\n        for (let j = 0; j < numFlips; j += 1) {\n            t = view[i + j];\n            view[i + j] = view[i + endByteIndex - j];\n            view[i + endByteIndex - j] = t;\n        }\n    }\n}\nexport function get_ctr(data_type) {\n    if (data_type === \"v2:object\") {\n        return globalThis.Array;\n    }\n    let match = data_type.match(/v2:([US])(\\d+)/);\n    if (match) {\n        let [, kind, chars] = match;\n        // @ts-expect-error\n        return (kind === \"U\" ? UnicodeStringArray : ByteStringArray).bind(null, Number(chars));\n    }\n    // @ts-expect-error - We've checked that the key exists\n    let ctr = {\n        int8: Int8Array,\n        int16: Int16Array,\n        int32: Int32Array,\n        int64: globalThis.BigInt64Array,\n        uint8: Uint8Array,\n        uint16: Uint16Array,\n        uint32: Uint32Array,\n        uint64: globalThis.BigUint64Array,\n        float16: globalThis.Float16Array,\n        float32: Float32Array,\n        float64: Float64Array,\n        bool: BoolArray,\n    }[data_type];\n    assert(ctr, `Unknown or unsupported data_type: ${data_type}`);\n    return ctr;\n}\n/** Compute strides for 'C' or 'F' ordered array from shape */\nexport function get_strides(shape, order) {\n    const rank = shape.length;\n    if (typeof order === \"string\") {\n        order =\n            order === \"C\"\n                ? Array.from({ length: rank }, (_, i) => i) // Row-major (identity order)\n                : Array.from({ length: rank }, (_, i) => rank - 1 - i); // Column-major (reverse order)\n    }\n    assert(rank === order.length, \"Order length must match the number of dimensions.\");\n    let step = 1;\n    let stride = new Array(rank);\n    for (let i = order.length - 1; i >= 0; i--) {\n        stride[order[i]] = step;\n        step *= shape[order[i]];\n    }\n    return stride;\n}\n// https://zarr-specs.readthedocs.io/en/latest/v3/core/v3.0.html#chunk-key-encoding\nexport function create_chunk_key_encoder({ name, configuration, }) {\n    if (name === \"default\") {\n        const separator = configuration?.separator ?? \"/\";\n        return (chunk_coords) => [\"c\", ...chunk_coords].join(separator);\n    }\n    if (name === \"v2\") {\n        const separator = configuration?.separator ?? \".\";\n        return (chunk_coords) => chunk_coords.join(separator) || \"0\";\n    }\n    throw new Error(`Unknown chunk key encoding: ${name}`);\n}\nfunction coerce_dtype(dtype) {\n    if (dtype === \"|O\") {\n        return { data_type: \"v2:object\" };\n    }\n    let match = dtype.match(/^([<|>])(.*)$/);\n    assert(match, `Invalid dtype: ${dtype}`);\n    let [, endian, rest] = match;\n    let data_type = {\n        b1: \"bool\",\n        i1: \"int8\",\n        u1: \"uint8\",\n        i2: \"int16\",\n        u2: \"uint16\",\n        i4: \"int32\",\n        u4: \"uint32\",\n        i8: \"int64\",\n        u8: \"uint64\",\n        f2: \"float16\",\n        f4: \"float32\",\n        f8: \"float64\",\n    }[rest] ??\n        (rest.startsWith(\"S\") || rest.startsWith(\"U\") ? `v2:${rest}` : undefined);\n    assert(data_type, `Unsupported or unknown dtype: ${dtype}`);\n    if (endian === \"|\") {\n        return { data_type };\n    }\n    return { data_type, endian: endian === \"<\" ? \"little\" : \"big\" };\n}\nexport function v2_to_v3_array_metadata(meta, attributes = {}) {\n    let codecs = [];\n    let dtype = coerce_dtype(meta.dtype);\n    if (meta.order === \"F\") {\n        codecs.push({ name: \"transpose\", configuration: { order: \"F\" } });\n    }\n    if (\"endian\" in dtype && dtype.endian === \"big\") {\n        codecs.push({ name: \"bytes\", configuration: { endian: \"big\" } });\n    }\n    for (let { id, ...configuration } of meta.filters ?? []) {\n        codecs.push({ name: id, configuration });\n    }\n    if (meta.compressor) {\n        let { id, ...configuration } = meta.compressor;\n        codecs.push({ name: id, configuration });\n    }\n    return {\n        zarr_format: 3,\n        node_type: \"array\",\n        shape: meta.shape,\n        data_type: dtype.data_type,\n        chunk_grid: {\n            name: \"regular\",\n            configuration: {\n                chunk_shape: meta.chunks,\n            },\n        },\n        chunk_key_encoding: {\n            name: \"v2\",\n            configuration: {\n                separator: meta.dimension_separator ?? \".\",\n            },\n        },\n        codecs,\n        fill_value: meta.fill_value,\n        attributes,\n    };\n}\nexport function v2_to_v3_group_metadata(_meta, attributes = {}) {\n    return {\n        zarr_format: 3,\n        node_type: \"group\",\n        attributes,\n    };\n}\nexport function is_dtype(dtype, query) {\n    if (query !== \"number\" &&\n        query !== \"bigint\" &&\n        query !== \"boolean\" &&\n        query !== \"object\" &&\n        query !== \"string\") {\n        return dtype === query;\n    }\n    let is_boolean = dtype === \"bool\";\n    if (query === \"boolean\")\n        return is_boolean;\n    let is_string = dtype.startsWith(\"v2:U\") || dtype.startsWith(\"v2:S\");\n    if (query === \"string\")\n        return is_string;\n    let is_bigint = dtype === \"int64\" || dtype === \"uint64\";\n    if (query === \"bigint\")\n        return is_bigint;\n    let is_object = dtype === \"v2:object\";\n    if (query === \"object\")\n        return is_object;\n    return !is_string && !is_bigint && !is_boolean && !is_object;\n}\nexport function is_sharding_codec(codec) {\n    return codec?.name === \"sharding_indexed\";\n}\nexport function ensure_correct_scalar(metadata) {\n    if ((metadata.data_type === \"uint64\" || metadata.data_type === \"int64\") &&\n        metadata.fill_value != null) {\n        // @ts-expect-error - We've narrowed the type of fill_value correctly\n        return BigInt(metadata.fill_value);\n    }\n    return metadata.fill_value;\n}\n/**\n * Ensures an error matches expected type(s), otherwise rethrows.\n *\n * Unmatched errors bubble up, like Python's `except`. Narrows error types for\n * type-safe property access.\n *\n * @see {@link https://gist.github.com/manzt/3702f19abb714e21c22ce48851c75abf}\n *\n * @example\n * ```ts\n * class DatabaseError extends Error { }\n * class NetworkError extends Error { }\n *\n * try {\n *   await db.query();\n * } catch (err) {\n *   rethrow_unless(err, DatabaseError, NetworkError);\n *   err // DatabaseError | NetworkError\n * }\n * ```\n *\n * @param error - The error to check\n * @param errors - Expected error type(s)\n * @throws The original error if it doesn't match expected type(s)\n */\nexport function rethrow_unless(error, ...errors) {\n    if (!errors.some((ErrorClass) => error instanceof ErrorClass)) {\n        throw error;\n    }\n}\n/**\n * Make an assertion.\n *\n * Usage\n * @example\n * ```ts\n * const value: boolean = Math.random() <= 0.5;\n * assert(value, \"value is greater than than 0.5!\");\n * value // true\n * ```\n *\n * @param expression - The expression to test.\n * @param msg - The optional message to display if the assertion fails.\n * @throws an {@link Error} if `expression` is not truthy.\n */\nexport function assert(expression, msg = \"\") {\n    if (!expression) {\n        throw new Error(msg);\n    }\n}\n", "import { assert } from \"../util.js\";\n/**\n * A codec for bit-rounding.\n *\n * Reduces floating-point precision by truncating mantissa bits during encoding.\n * Decoding is a no-op as the process is lossy and precision cannot be restored.\n *\n * Note: {@link BitroundCodec.encode} is not yet implemented since Zarrita is\n * primarily used in read-only contexts (web browser). If you need encoding support,\n * please open an issue at {@link https://github.com/manzt/zarrita.js/issues}.\n *\n * @see {@link https://github.com/zarr-developers/numcodecs/blob/main/numcodecs/bitround.py}\n * for the original Python implementation.\n *\n * @remarks\n * Data types are not validated, and `float16` arrays are not supported (reflecting browser support).\n */\nexport class BitroundCodec {\n    kind = \"array_to_array\";\n    constructor(configuration, _meta) {\n        assert(configuration.keepbits >= 0, \"keepbits must be zero or positive\");\n    }\n    static fromConfig(configuration, meta) {\n        return new BitroundCodec(configuration, meta);\n    }\n    /**\n     * Encode a chunk of data with bit-rounding.\n     * @param _arr - The chunk to encode\n     */\n    encode(_arr) {\n        throw new Error(\"`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.\");\n    }\n    /**\n     * Decode a chunk of data (no-op).\n     * @param arr - The chunk to decode\n     * @returns The decoded chunk\n     */\n    decode(arr) {\n        return arr; // No-op as bit-rounding is lossy\n    }\n}\n", "import { byteswap_inplace, get_ctr, get_strides } from \"../util.js\";\nconst LITTLE_ENDIAN_OS = system_is_little_endian();\nfunction system_is_little_endian() {\n    const a = new Uint32Array([0x12345678]);\n    const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return !(b[0] === 0x12);\n}\nfunction bytes_per_element(TypedArray) {\n    if (\"BYTES_PER_ELEMENT\" in TypedArray) {\n        return TypedArray.BYTES_PER_ELEMENT;\n    }\n    // Unicode string array is backed by a Int32Array.\n    return 4;\n}\nexport class BytesCodec {\n    kind = \"array_to_bytes\";\n    #stride;\n    #TypedArray;\n    #BYTES_PER_ELEMENT;\n    #shape;\n    #endian;\n    constructor(configuration, meta) {\n        this.#endian = configuration?.endian;\n        this.#TypedArray = get_ctr(meta.data_type);\n        this.#shape = meta.shape;\n        this.#stride = get_strides(meta.shape, \"C\");\n        // TODO: fix me.\n        // hack to get bytes per element since it's dynamic for string types.\n        const sample = new this.#TypedArray(0);\n        this.#BYTES_PER_ELEMENT = sample.BYTES_PER_ELEMENT;\n    }\n    static fromConfig(configuration, meta) {\n        return new BytesCodec(configuration, meta);\n    }\n    encode(arr) {\n        let bytes = new Uint8Array(arr.data.buffer);\n        if (LITTLE_ENDIAN_OS && this.#endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return bytes;\n    }\n    decode(bytes) {\n        if (LITTLE_ENDIAN_OS && this.#endian === \"big\") {\n            byteswap_inplace(bytes, bytes_per_element(this.#TypedArray));\n        }\n        return {\n            data: new this.#TypedArray(bytes.buffer, bytes.byteOffset, bytes.byteLength / this.#BYTES_PER_ELEMENT),\n            shape: this.#shape,\n            stride: this.#stride,\n        };\n    }\n}\n", "export class Crc32cCodec {\n    kind = \"bytes_to_bytes\";\n    static fromConfig() {\n        return new Crc32cCodec();\n    }\n    encode(_) {\n        throw new Error(\"Not implemented\");\n    }\n    decode(arr) {\n        return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength - 4);\n    }\n}\n", "import { assert, get_strides, json_decode_object } from \"../util.js\";\n// Reference: https://stackoverflow.com/a/21897413\nfunction throw_on_nan_replacer(_key, value) {\n    assert(!Number.isNaN(value), \"JsonCodec allow_nan is false but NaN was encountered during encoding.\");\n    assert(value !== Number.POSITIVE_INFINITY, \"JsonCodec allow_nan is false but Infinity was encountered during encoding.\");\n    assert(value !== Number.NEGATIVE_INFINITY, \"JsonCodec allow_nan is false but -Infinity was encountered during encoding.\");\n    return value;\n}\n// Reference: https://gist.github.com/davidfurlong/463a83a33b70a3b6618e97ec9679e490\nfunction sort_keys_replacer(_key, value) {\n    return value instanceof Object && !Array.isArray(value)\n        ? Object.keys(value)\n            .sort()\n            .reduce((sorted, key) => {\n            sorted[key] = value[key];\n            return sorted;\n        }, {})\n        : value;\n}\nexport class JsonCodec {\n    configuration;\n    kind = \"array_to_bytes\";\n    #encoder_config;\n    #decoder_config;\n    constructor(configuration = {}) {\n        this.configuration = configuration;\n        // Reference: https://github.com/zarr-developers/numcodecs/blob/0878717a3613d91a453fe3d3716aa9c67c023a8b/numcodecs/json.py#L36\n        const { encoding = \"utf-8\", skipkeys = false, ensure_ascii = true, check_circular = true, allow_nan = true, sort_keys = true, indent, strict = true, } = configuration;\n        let separators = configuration.separators;\n        if (!separators) {\n            // ensure separators are explicitly specified, and consistent behaviour across\n            // Python versions, and most compact representation if indent is None\n            if (!indent) {\n                separators = [\",\", \":\"];\n            }\n            else {\n                separators = [\", \", \": \"];\n            }\n        }\n        this.#encoder_config = {\n            encoding,\n            skipkeys,\n            ensure_ascii,\n            check_circular,\n            allow_nan,\n            indent,\n            separators,\n            sort_keys,\n        };\n        this.#decoder_config = { strict };\n    }\n    static fromConfig(configuration) {\n        return new JsonCodec(configuration);\n    }\n    encode(buf) {\n        const { indent, encoding, ensure_ascii, check_circular, allow_nan, sort_keys, } = this.#encoder_config;\n        assert(encoding === \"utf-8\", \"JsonCodec does not yet support non-utf-8 encoding.\");\n        const replacer_functions = [];\n        // By default, for JSON.stringify,\n        // a TypeError will be thrown if one attempts to encode an object with circular references\n        assert(check_circular, \"JsonCodec does not yet support skipping the check for circular references during encoding.\");\n        if (!allow_nan) {\n            // Throw if NaN/Infinity/-Infinity are encountered during encoding.\n            replacer_functions.push(throw_on_nan_replacer);\n        }\n        if (sort_keys) {\n            // We can ensure keys are sorted but not really the opposite since\n            // there is no guarantee of key ordering in JS.\n            replacer_functions.push(sort_keys_replacer);\n        }\n        const items = Array.from(buf.data);\n        items.push(\"|O\");\n        items.push(buf.shape);\n        let replacer = undefined;\n        if (replacer_functions.length) {\n            replacer = (key, value) => {\n                let new_value = value;\n                for (let sub_replacer of replacer_functions) {\n                    new_value = sub_replacer(key, new_value);\n                }\n                return new_value;\n            };\n        }\n        let json_str = JSON.stringify(items, replacer, indent);\n        if (ensure_ascii) {\n            // If ensure_ascii is true (the default), the output is guaranteed\n            // to have all incoming non-ASCII characters escaped.\n            // If ensure_ascii is false, these characters will be output as-is.\n            // Reference: https://stackoverflow.com/a/31652607\n            json_str = json_str.replace(/[\\u007F-\\uFFFF]/g, (chr) => {\n                const full_str = `0000${chr.charCodeAt(0).toString(16)}`;\n                const sub_str = full_str.substring(full_str.length - 4);\n                return `\\\\u${sub_str}`;\n            });\n        }\n        return new TextEncoder().encode(json_str);\n    }\n    decode(bytes) {\n        const { strict } = this.#decoder_config;\n        // (i.e., allowing control characters inside strings)\n        assert(strict, \"JsonCodec does not yet support non-strict decoding.\");\n        const items = json_decode_object(bytes);\n        const shape = items.pop();\n        items.pop(); // Pop off dtype (unused)\n        // O-d case\n        assert(shape, \"0D not implemented for JsonCodec.\");\n        const stride = get_strides(shape, \"C\");\n        const data = items;\n        return { data, shape, stride };\n    }\n}\n", "import { BoolArray, ByteStringArray, UnicodeStringArray, } from \"../typedarray.js\";\nimport { assert, get_strides } from \"../util.js\";\nfunction proxy(arr) {\n    if (arr instanceof BoolArray ||\n        arr instanceof ByteStringArray ||\n        arr instanceof UnicodeStringArray) {\n        // @ts-expect-error - TS cannot infer arr is a TypedArrayProxy<D>\n        const arrp = new Proxy(arr, {\n            get(target, prop) {\n                return target.get(Number(prop));\n            },\n            set(target, prop, value) {\n                // @ts-expect-error - value is OK\n                target.set(Number(prop), value);\n                return true;\n            },\n        });\n        return arrp;\n    }\n    // @ts-expect-error - TS cannot infer arr is a TypedArrayProxy<D>\n    return arr;\n}\nfunction empty_like(chunk, order) {\n    let data;\n    if (chunk.data instanceof ByteStringArray ||\n        chunk.data instanceof UnicodeStringArray) {\n        data = new chunk.constructor(\n        // @ts-expect-error\n        chunk.data.length, chunk.data.chars);\n    }\n    else {\n        data = new chunk.constructor(chunk.data.length);\n    }\n    return {\n        data,\n        shape: chunk.shape,\n        stride: get_strides(chunk.shape, order),\n    };\n}\nfunction convert_array_order(src, target) {\n    let out = empty_like(src, target);\n    let n_dims = src.shape.length;\n    let size = src.data.length;\n    let index = Array(n_dims).fill(0);\n    let src_data = proxy(src.data);\n    let out_data = proxy(out.data);\n    for (let src_idx = 0; src_idx < size; src_idx++) {\n        let out_idx = 0;\n        for (let dim = 0; dim < n_dims; dim++) {\n            out_idx += index[dim] * out.stride[dim];\n        }\n        out_data[out_idx] = src_data[src_idx];\n        index[0] += 1;\n        for (let dim = 0; dim < n_dims; dim++) {\n            if (index[dim] === src.shape[dim]) {\n                if (dim + 1 === n_dims) {\n                    break;\n                }\n                index[dim] = 0;\n                index[dim + 1] += 1;\n            }\n        }\n    }\n    return out;\n}\n/** Determine the memory order (axis permutation) for a chunk */\nfunction get_order(chunk) {\n    let rank = chunk.shape.length;\n    assert(rank === chunk.stride.length, \"Shape and stride must have the same length.\");\n    return chunk.stride\n        .map((s, i) => ({ stride: s, index: i }))\n        .sort((a, b) => b.stride - a.stride)\n        .map((entry) => entry.index);\n}\nfunction matches_order(chunk, target) {\n    let source = get_order(chunk);\n    assert(source.length === target.length, \"Orders must match\");\n    return source.every((dim, i) => dim === target[i]);\n}\nexport class TransposeCodec {\n    kind = \"array_to_array\";\n    #order;\n    #inverseOrder;\n    constructor(configuration, meta) {\n        let value = configuration.order ?? \"C\";\n        let rank = meta.shape.length;\n        let order = new Array(rank);\n        let inverseOrder = new Array(rank);\n        if (value === \"C\") {\n            for (let i = 0; i < rank; ++i) {\n                order[i] = i;\n                inverseOrder[i] = i;\n            }\n        }\n        else if (value === \"F\") {\n            for (let i = 0; i < rank; ++i) {\n                order[i] = rank - i - 1;\n                inverseOrder[i] = rank - i - 1;\n            }\n        }\n        else {\n            order = value;\n            order.forEach((x, i) => {\n                assert(inverseOrder[x] === undefined, `Invalid permutation: ${JSON.stringify(value)}`);\n                inverseOrder[x] = i;\n            });\n        }\n        this.#order = order;\n        this.#inverseOrder = inverseOrder;\n    }\n    static fromConfig(configuration, meta) {\n        return new TransposeCodec(configuration, meta);\n    }\n    encode(arr) {\n        if (matches_order(arr, this.#inverseOrder)) {\n            // can skip making a copy\n            return arr;\n        }\n        return convert_array_order(arr, this.#inverseOrder);\n    }\n    decode(arr) {\n        return {\n            data: arr.data,\n            shape: arr.shape,\n            stride: get_strides(arr.shape, this.#order),\n        };\n    }\n}\n", "import { get_strides } from \"../util.js\";\nexport class VLenUTF8 {\n    kind = \"array_to_bytes\";\n    #shape;\n    #strides;\n    constructor(shape) {\n        this.#shape = shape;\n        this.#strides = get_strides(shape, \"C\");\n    }\n    static fromConfig(_, meta) {\n        return new VLenUTF8(meta.shape);\n    }\n    encode(_chunk) {\n        throw new Error(\"Method not implemented.\");\n    }\n    decode(bytes) {\n        let decoder = new TextDecoder();\n        let view = new DataView(bytes.buffer);\n        let data = Array(view.getUint32(0, true));\n        let pos = 4;\n        for (let i = 0; i < data.length; i++) {\n            let item_length = view.getUint32(pos, true);\n            pos += 4;\n            data[i] = decoder.decode(bytes.buffer.slice(pos, pos + item_length));\n            pos += item_length;\n        }\n        return { data, shape: this.#shape, stride: this.#strides };\n    }\n}\n", "import { BitroundCodec } from \"./codecs/bitround.js\";\nimport { BytesCodec } from \"./codecs/bytes.js\";\nimport { Crc32cCodec } from \"./codecs/crc32c.js\";\nimport { JsonCodec } from \"./codecs/json2.js\";\nimport { TransposeCodec } from \"./codecs/transpose.js\";\nimport { VLenUTF8 } from \"./codecs/vlen-utf8.js\";\nimport { assert } from \"./util.js\";\nfunction create_default_registry() {\n    return new Map()\n        .set(\"blosc\", () => import(\"numcodecs/blosc\").then((m) => m.default))\n        .set(\"gzip\", () => import(\"numcodecs/gzip\").then((m) => m.default))\n        .set(\"lz4\", () => import(\"numcodecs/lz4\").then((m) => m.default))\n        .set(\"zlib\", () => import(\"numcodecs/zlib\").then((m) => m.default))\n        .set(\"zstd\", () => import(\"numcodecs/zstd\").then((m) => m.default))\n        .set(\"transpose\", () => TransposeCodec)\n        .set(\"bytes\", () => BytesCodec)\n        .set(\"crc32c\", () => Crc32cCodec)\n        .set(\"vlen-utf8\", () => VLenUTF8)\n        .set(\"json2\", () => JsonCodec)\n        .set(\"bitround\", () => BitroundCodec);\n}\nexport const registry = create_default_registry();\nexport function create_codec_pipeline(chunk_metadata) {\n    let codecs;\n    return {\n        async encode(chunk) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (const codec of codecs.array_to_array) {\n                chunk = await codec.encode(chunk);\n            }\n            let bytes = await codecs.array_to_bytes.encode(chunk);\n            for (const codec of codecs.bytes_to_bytes) {\n                bytes = await codec.encode(bytes);\n            }\n            return bytes;\n        },\n        async decode(bytes) {\n            if (!codecs)\n                codecs = await load_codecs(chunk_metadata);\n            for (let i = codecs.bytes_to_bytes.length - 1; i >= 0; i--) {\n                bytes = await codecs.bytes_to_bytes[i].decode(bytes);\n            }\n            let chunk = await codecs.array_to_bytes.decode(bytes);\n            for (let i = codecs.array_to_array.length - 1; i >= 0; i--) {\n                chunk = await codecs.array_to_array[i].decode(chunk);\n            }\n            return chunk;\n        },\n    };\n}\nasync function load_codecs(chunk_meta) {\n    let promises = chunk_meta.codecs.map(async (meta) => {\n        let Codec = await registry.get(meta.name)?.();\n        assert(Codec, `Unknown codec: ${meta.name}`);\n        return { Codec, meta };\n    });\n    let array_to_array = [];\n    let array_to_bytes;\n    let bytes_to_bytes = [];\n    for await (let { Codec, meta } of promises) {\n        let codec = Codec.fromConfig(meta.configuration, chunk_meta);\n        switch (codec.kind) {\n            case \"array_to_array\":\n                array_to_array.push(codec);\n                break;\n            case \"array_to_bytes\":\n                array_to_bytes = codec;\n                break;\n            default:\n                bytes_to_bytes.push(codec);\n        }\n    }\n    if (!array_to_bytes) {\n        assert(is_typed_array_like_meta(chunk_meta), `Cannot encode ${chunk_meta.data_type} to bytes without a codec`);\n        array_to_bytes = BytesCodec.fromConfig({ endian: \"little\" }, chunk_meta);\n    }\n    return { array_to_array, array_to_bytes, bytes_to_bytes };\n}\nfunction is_typed_array_like_meta(meta) {\n    return meta.data_type !== \"v2:object\";\n}\n", "import { assert } from \"../util.js\";\nimport { create_codec_pipeline } from \"../codecs.js\";\nconst MAX_BIG_UINT = 18446744073709551615n;\nexport function create_sharded_chunk_getter(location, shard_shape, encode_shard_key, sharding_config) {\n    assert(location.store.getRange, \"Store does not support range requests\");\n    let get_range = location.store.getRange.bind(location.store);\n    let index_shape = shard_shape.map((d, i) => d / sharding_config.chunk_shape[i]);\n    let index_codec = create_codec_pipeline({\n        data_type: \"uint64\",\n        shape: [...index_shape, 2],\n        codecs: sharding_config.index_codecs,\n    });\n    let cache = {};\n    return async (chunk_coord) => {\n        let shard_coord = chunk_coord.map((d, i) => Math.floor(d / index_shape[i]));\n        let shard_path = location.resolve(encode_shard_key(shard_coord)).path;\n        let index;\n        if (shard_path in cache) {\n            index = cache[shard_path];\n        }\n        else {\n            let checksum_size = 4;\n            let index_size = 16 * index_shape.reduce((a, b) => a * b, 1);\n            let bytes = await get_range(shard_path, {\n                suffixLength: index_size + checksum_size,\n            });\n            index = cache[shard_path] = bytes\n                ? await index_codec.decode(bytes)\n                : null;\n        }\n        if (index === null) {\n            return undefined;\n        }\n        let { data, shape, stride } = index;\n        let linear_offset = chunk_coord\n            .map((d, i) => d % shape[i])\n            .reduce((acc, sel, idx) => acc + sel * stride[idx], 0);\n        let offset = data[linear_offset];\n        let length = data[linear_offset + 1];\n        // write null chunk when 2^64-1 indicates fill value\n        if (offset === MAX_BIG_UINT && length === MAX_BIG_UINT) {\n            return undefined;\n        }\n        return get_range(shard_path, {\n            offset: Number(offset),\n            length: Number(length),\n        });\n    };\n}\n", "import { create_codec_pipeline } from \"./codecs.js\";\nimport { create_sharded_chunk_getter } from \"./codecs/sharding.js\";\nimport { is_dtype, is_sharding_codec, } from \"./util.js\";\nimport { create_chunk_key_encoder, ensure_correct_scalar, get_ctr, get_strides, } from \"./util.js\";\nexport class Location {\n    store;\n    path;\n    constructor(store, path = \"/\") {\n        this.store = store;\n        this.path = path;\n    }\n    resolve(path) {\n        // reuse URL resolution logic built into the browser\n        // handles relative paths, absolute paths, etc.\n        let root = new URL(`file://${this.path.endsWith(\"/\") ? this.path : `${this.path}/`}`);\n        return new Location(this.store, new URL(path, root).pathname);\n    }\n}\nexport function root(store) {\n    return new Location(store ?? new Map());\n}\nexport class Group extends Location {\n    kind = \"group\";\n    #metadata;\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = metadata;\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n}\nfunction get_array_order(codecs) {\n    const maybe_transpose_codec = codecs.find((c) => c.name === \"transpose\");\n    // @ts-expect-error - TODO: Should validate?\n    return maybe_transpose_codec?.configuration?.order ?? \"C\";\n}\nconst CONTEXT_MARKER = Symbol(\"zarrita.context\");\nexport function get_context(obj) {\n    return obj[CONTEXT_MARKER];\n}\nfunction create_context(location, metadata) {\n    let { configuration } = metadata.codecs.find(is_sharding_codec) ?? {};\n    let shared_context = {\n        encode_chunk_key: create_chunk_key_encoder(metadata.chunk_key_encoding),\n        TypedArray: get_ctr(metadata.data_type),\n        fill_value: metadata.fill_value,\n    };\n    if (configuration) {\n        let native_order = get_array_order(configuration.codecs);\n        return {\n            ...shared_context,\n            kind: \"sharded\",\n            chunk_shape: configuration.chunk_shape,\n            codec: create_codec_pipeline({\n                data_type: metadata.data_type,\n                shape: configuration.chunk_shape,\n                codecs: configuration.codecs,\n            }),\n            get_strides(shape) {\n                return get_strides(shape, native_order);\n            },\n            get_chunk_bytes: create_sharded_chunk_getter(location, metadata.chunk_grid.configuration.chunk_shape, shared_context.encode_chunk_key, configuration),\n        };\n    }\n    let native_order = get_array_order(metadata.codecs);\n    return {\n        ...shared_context,\n        kind: \"regular\",\n        chunk_shape: metadata.chunk_grid.configuration.chunk_shape,\n        codec: create_codec_pipeline({\n            data_type: metadata.data_type,\n            shape: metadata.chunk_grid.configuration.chunk_shape,\n            codecs: metadata.codecs,\n        }),\n        get_strides(shape) {\n            return get_strides(shape, native_order);\n        },\n        async get_chunk_bytes(chunk_coords, options) {\n            let chunk_key = shared_context.encode_chunk_key(chunk_coords);\n            let chunk_path = location.resolve(chunk_key).path;\n            return location.store.get(chunk_path, options);\n        },\n    };\n}\nexport class Array extends Location {\n    kind = \"array\";\n    #metadata;\n    [CONTEXT_MARKER];\n    constructor(store, path, metadata) {\n        super(store, path);\n        this.#metadata = {\n            ...metadata,\n            fill_value: ensure_correct_scalar(metadata),\n        };\n        this[CONTEXT_MARKER] = create_context(this, metadata);\n    }\n    get attrs() {\n        return this.#metadata.attributes;\n    }\n    get shape() {\n        return this.#metadata.shape;\n    }\n    get chunks() {\n        return this[CONTEXT_MARKER].chunk_shape;\n    }\n    get dtype() {\n        return this.#metadata.data_type;\n    }\n    async getChunk(chunk_coords, options) {\n        let context = this[CONTEXT_MARKER];\n        let maybe_bytes = await context.get_chunk_bytes(chunk_coords, options);\n        if (!maybe_bytes) {\n            let size = context.chunk_shape.reduce((a, b) => a * b, 1);\n            let data = new context.TypedArray(size);\n            // @ts-expect-error: TS can't infer that `fill_value` is union (assumes never) but this is ok\n            data.fill(context.fill_value);\n            return {\n                data,\n                shape: context.chunk_shape,\n                stride: context.get_strides(context.chunk_shape),\n            };\n        }\n        return context.codec.decode(maybe_bytes);\n    }\n    /**\n     * A helper method to narrow `zarr.Array` Dtype.\n     *\n     * ```typescript\n     * let arr: zarr.Array<DataType, FetchStore> = zarr.open(store, { kind: \"array\" });\n     *\n     * // Option 1: narrow by scalar type (e.g. \"bool\", \"raw\", \"bigint\", \"number\")\n     * if (arr.is(\"bigint\")) {\n     *   // zarr.Array<\"int64\" | \"uint64\", FetchStore>\n     * }\n     *\n     * // Option 3: exact match\n     * if (arr.is(\"float32\")) {\n     *   // zarr.Array<\"float32\", FetchStore, \"/\">\n     * }\n     * ```\n     */\n    is(query) {\n        return is_dtype(this.dtype, query);\n    }\n}\n", "import { KeyError, NodeNotFoundError } from \"./errors.js\";\nimport { Array, Group, Location } from \"./hierarchy.js\";\nimport { ensure_correct_scalar, json_decode_object, rethrow_unless, v2_to_v3_array_metadata, v2_to_v3_group_metadata, } from \"./util.js\";\nlet VERSION_COUNTER = create_version_counter();\nfunction create_version_counter() {\n    let version_counts = new WeakMap();\n    function get_counts(store) {\n        let counts = version_counts.get(store) ?? { v2: 0, v3: 0 };\n        version_counts.set(store, counts);\n        return counts;\n    }\n    return {\n        increment(store, version) {\n            get_counts(store)[version] += 1;\n        },\n        version_max(store) {\n            let counts = get_counts(store);\n            return counts.v3 > counts.v2 ? \"v3\" : \"v2\";\n        },\n    };\n}\nasync function load_attrs(location) {\n    let meta_bytes = await location.store.get(location.resolve(\".zattrs\").path);\n    if (!meta_bytes)\n        return {};\n    return json_decode_object(meta_bytes);\n}\nasync function open_v2(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let attrs = {};\n    if (options.attrs ?? true)\n        attrs = await load_attrs(loc);\n    if (options.kind === \"array\")\n        return open_array_v2(loc, attrs);\n    if (options.kind === \"group\")\n        return open_group_v2(loc, attrs);\n    return open_array_v2(loc, attrs).catch((err) => {\n        rethrow_unless(err, NodeNotFoundError);\n        return open_group_v2(loc, attrs);\n    });\n}\nasync function open_array_v2(location, attrs) {\n    let { path } = location.resolve(\".zarray\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(\"v2 array\", {\n            cause: new KeyError(path),\n        });\n    }\n    VERSION_COUNTER.increment(location.store, \"v2\");\n    return new Array(location.store, location.path, v2_to_v3_array_metadata(json_decode_object(meta), attrs));\n}\nasync function open_group_v2(location, attrs) {\n    let { path } = location.resolve(\".zgroup\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(\"v2 group\", {\n            cause: new KeyError(path),\n        });\n    }\n    VERSION_COUNTER.increment(location.store, \"v2\");\n    return new Group(location.store, location.path, v2_to_v3_group_metadata(json_decode_object(meta), attrs));\n}\nasync function _open_v3(location) {\n    let { store, path } = location.resolve(\"zarr.json\");\n    let meta = await location.store.get(path);\n    if (!meta) {\n        throw new NodeNotFoundError(\"v3 array or group\", {\n            cause: new KeyError(path),\n        });\n    }\n    let meta_doc = json_decode_object(meta);\n    if (meta_doc.node_type === \"array\") {\n        meta_doc.fill_value = ensure_correct_scalar(meta_doc);\n    }\n    return meta_doc.node_type === \"array\"\n        ? new Array(store, location.path, meta_doc)\n        : new Group(store, location.path, meta_doc);\n}\nasync function open_v3(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    let node = await _open_v3(loc);\n    VERSION_COUNTER.increment(loc.store, \"v3\");\n    if (options.kind === undefined)\n        return node;\n    if (options.kind === \"array\" && node instanceof Array)\n        return node;\n    if (options.kind === \"group\" && node instanceof Group)\n        return node;\n    let kind = node instanceof Array ? \"array\" : \"group\";\n    throw new Error(`Expected node of kind ${options.kind}, found ${kind}.`);\n}\nexport async function open(location, options = {}) {\n    let store = \"store\" in location ? location.store : location;\n    let version_max = VERSION_COUNTER.version_max(store);\n    // Use the open function for the version with the most successful opens.\n    // Note that here we use the dot syntax to access the open functions\n    // because this enables us to use vi.spyOn during testing.\n    let open_primary = version_max === \"v2\" ? open.v2 : open.v3;\n    let open_secondary = version_max === \"v2\" ? open.v3 : open.v2;\n    return open_primary(location, options).catch((err) => {\n        rethrow_unless(err, NodeNotFoundError);\n        return open_secondary(location, options);\n    });\n}\nopen.v2 = open_v2;\nopen.v3 = open_v3;\n", "import { Array, Group, Location } from \"./hierarchy.js\";\nimport { json_encode_object } from \"./util.js\";\nexport async function create(location, options = {}) {\n    let loc = \"store\" in location ? location : new Location(location);\n    if (\"shape\" in options) {\n        let arr = await create_array(loc, options);\n        return arr;\n    }\n    return create_group(loc, options);\n}\nasync function create_group(location, options = {}) {\n    let metadata = {\n        zarr_format: 3,\n        node_type: \"group\",\n        attributes: options.attributes ?? {},\n    };\n    await location.store.set(location.resolve(\"zarr.json\").path, json_encode_object(metadata));\n    return new Group(location.store, location.path, metadata);\n}\nasync function create_array(location, options) {\n    let metadata = {\n        zarr_format: 3,\n        node_type: \"array\",\n        shape: options.shape,\n        data_type: options.data_type,\n        chunk_grid: {\n            name: \"regular\",\n            configuration: {\n                chunk_shape: options.chunk_shape,\n            },\n        },\n        chunk_key_encoding: {\n            name: \"default\",\n            configuration: {\n                separator: options.chunk_separator ?? \"/\",\n            },\n        },\n        codecs: options.codecs ?? [],\n        fill_value: options.fill_value ?? null,\n        attributes: options.attributes ?? {},\n    };\n    await location.store.set(location.resolve(\"zarr.json\").path, json_encode_object(metadata));\n    return new Array(location.store, location.path, metadata);\n}\n", "/** Similar to python's `range` function. Supports positive ranges only. */\nexport function* range(start, stop, step = 1) {\n    if (stop === undefined) {\n        stop = start;\n        start = 0;\n    }\n    for (let i = start; i < stop; i += step) {\n        yield i;\n    }\n}\n/**\n * python-like itertools.product generator\n * https://gist.github.com/cybercase/db7dde901d7070c98c48\n */\nexport function* product(...iterables) {\n    if (iterables.length === 0) {\n        return;\n    }\n    // make a list of iterators from the iterables\n    const iterators = iterables.map((it) => it[Symbol.iterator]());\n    const results = iterators.map((it) => it.next());\n    if (results.some((r) => r.done)) {\n        throw new Error(\"Input contains an empty iterator.\");\n    }\n    for (let i = 0;;) {\n        if (results[i].done) {\n            // reset the current iterator\n            iterators[i] = iterables[i][Symbol.iterator]();\n            results[i] = iterators[i].next();\n            // advance, and exit if we've reached the end\n            if (++i >= iterators.length) {\n                return;\n            }\n        }\n        else {\n            // @ts-expect-error - TS can't infer this\n            yield results.map(({ value }) => value);\n            i = 0;\n        }\n        results[i] = iterators[i].next();\n    }\n}\n// https://github.com/python/cpython/blob/263c0dd16017613c5ea2fbfc270be4de2b41b5ad/Objects/sliceobject.c#L376-L519\nexport function slice_indices({ start, stop, step }, length) {\n    if (step === 0) {\n        throw new Error(\"slice step cannot be zero\");\n    }\n    step = step ?? 1;\n    const step_is_negative = step < 0;\n    /* Find lower and upper bounds for start and stop. */\n    const [lower, upper] = step_is_negative ? [-1, length - 1] : [0, length];\n    /* Compute start. */\n    if (start === null) {\n        start = step_is_negative ? upper : lower;\n    }\n    else {\n        if (start < 0) {\n            start += length;\n            if (start < lower) {\n                start = lower;\n            }\n        }\n        else if (start > upper) {\n            start = upper;\n        }\n    }\n    /* Compute stop. */\n    if (stop === null) {\n        stop = step_is_negative ? lower : upper;\n    }\n    else {\n        if (stop < 0) {\n            stop += length;\n            if (stop < lower) {\n                stop = lower;\n            }\n        }\n        else if (stop > upper) {\n            stop = upper;\n        }\n    }\n    return [start, stop, step];\n}\nexport function slice(start, stop, step = null) {\n    if (stop === undefined) {\n        stop = start;\n        start = null;\n    }\n    return {\n        start,\n        stop,\n        step,\n    };\n}\n/** Built-in \"queue\" for awaiting promises. */\nexport function create_queue() {\n    const promises = [];\n    return {\n        add: (fn) => promises.push(fn()),\n        onIdle: () => Promise.all(promises),\n    };\n}\n", "import { product, range, slice, slice_indices } from \"./util.js\";\nexport class IndexError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = \"IndexError\";\n    }\n}\nfunction err_too_many_indices(selection, shape) {\n    throw new IndexError(`too many indicies for array; expected ${shape.length}, got ${selection.length}`);\n}\nfunction err_boundscheck(dim_len) {\n    throw new IndexError(`index out of bounds for dimension with length ${dim_len}`);\n}\nfunction err_negative_step() {\n    throw new IndexError(\"only slices with step >= 1 are supported\");\n}\nfunction check_selection_length(selection, shape) {\n    if (selection.length > shape.length) {\n        err_too_many_indices(selection, shape);\n    }\n}\nexport function normalize_integer_selection(dim_sel, dim_len) {\n    // normalize type to int\n    dim_sel = Math.trunc(dim_sel);\n    // handle wraparound\n    if (dim_sel < 0) {\n        dim_sel = dim_len + dim_sel;\n    }\n    // handle out of bounds\n    if (dim_sel >= dim_len || dim_sel < 0) {\n        err_boundscheck(dim_len);\n    }\n    return dim_sel;\n}\nclass IntDimIndexer {\n    dim_sel;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        dim_sel = normalize_integer_selection(dim_sel, dim_len);\n        // store properties\n        this.dim_sel = dim_sel;\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = 1;\n    }\n    *[Symbol.iterator]() {\n        const dim_chunk_ix = Math.floor(this.dim_sel / this.dim_chunk_len);\n        const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n        const dim_chunk_sel = this.dim_sel - dim_offset;\n        yield { dim_chunk_ix, dim_chunk_sel };\n    }\n}\nclass SliceDimIndexer {\n    start;\n    stop;\n    step;\n    dim_len;\n    dim_chunk_len;\n    nitems;\n    nchunks;\n    constructor({ dim_sel, dim_len, dim_chunk_len }) {\n        // normalize\n        const [start, stop, step] = slice_indices(dim_sel, dim_len);\n        this.start = start;\n        this.stop = stop;\n        this.step = step;\n        if (this.step < 1)\n            err_negative_step();\n        // store properties\n        this.dim_len = dim_len;\n        this.dim_chunk_len = dim_chunk_len;\n        this.nitems = Math.max(0, Math.ceil((this.stop - this.start) / this.step));\n        this.nchunks = Math.ceil(this.dim_len / this.dim_chunk_len);\n    }\n    *[Symbol.iterator]() {\n        // figure out the range of chunks we need to visit\n        const dim_chunk_ix_from = Math.floor(this.start / this.dim_chunk_len);\n        const dim_chunk_ix_to = Math.ceil(this.stop / this.dim_chunk_len);\n        for (const dim_chunk_ix of range(dim_chunk_ix_from, dim_chunk_ix_to)) {\n            // compute offsets for chunk within overall array\n            const dim_offset = dim_chunk_ix * this.dim_chunk_len;\n            const dim_limit = Math.min(this.dim_len, (dim_chunk_ix + 1) * this.dim_chunk_len);\n            // determine chunk length, accounting for trailing chunk\n            const dim_chunk_len = dim_limit - dim_offset;\n            let dim_out_offset = 0;\n            let dim_chunk_sel_start = 0;\n            if (this.start < dim_offset) {\n                // selection start before current chunk\n                const remainder = (dim_offset - this.start) % this.step;\n                if (remainder)\n                    dim_chunk_sel_start += this.step - remainder;\n                // compute number of previous items, provides offset into output array\n                dim_out_offset = Math.ceil((dim_offset - this.start) / this.step);\n            }\n            else {\n                // selection starts within current chunk\n                dim_chunk_sel_start = this.start - dim_offset;\n            }\n            // selection starts within current chunk if true,\n            // otherwise selection ends after current chunk.\n            const dim_chunk_sel_stop = this.stop > dim_limit ? dim_chunk_len : this.stop - dim_offset;\n            const dim_chunk_sel = [\n                dim_chunk_sel_start,\n                dim_chunk_sel_stop,\n                this.step,\n            ];\n            const dim_chunk_nitems = Math.ceil((dim_chunk_sel_stop - dim_chunk_sel_start) / this.step);\n            const dim_out_sel = [\n                dim_out_offset,\n                dim_out_offset + dim_chunk_nitems,\n                1,\n            ];\n            yield { dim_chunk_ix, dim_chunk_sel, dim_out_sel };\n        }\n    }\n}\nexport function normalize_selection(selection, shape) {\n    let normalized = [];\n    if (selection === null) {\n        normalized = shape.map((_) => slice(null));\n    }\n    else if (Array.isArray(selection)) {\n        normalized = selection.map((s) => s ?? slice(null));\n    }\n    check_selection_length(normalized, shape);\n    return normalized;\n}\nexport class BasicIndexer {\n    dim_indexers;\n    shape;\n    constructor({ selection, shape, chunk_shape }) {\n        // setup per-dimension indexers\n        this.dim_indexers = normalize_selection(selection, shape).map((dim_sel, i) => {\n            return new (typeof dim_sel === \"number\" ? IntDimIndexer : SliceDimIndexer)({\n                // @ts-expect-error ts inference not strong enough to know correct chunk\n                dim_sel: dim_sel,\n                dim_len: shape[i],\n                dim_chunk_len: chunk_shape[i],\n            });\n        });\n        this.shape = this.dim_indexers\n            .filter((ixr) => ixr instanceof SliceDimIndexer)\n            .map((sixr) => sixr.nitems);\n    }\n    *[Symbol.iterator]() {\n        for (const dim_projections of product(...this.dim_indexers)) {\n            const chunk_coords = dim_projections.map((p) => p.dim_chunk_ix);\n            const mapping = dim_projections.map((p) => {\n                if (\"dim_out_sel\" in p) {\n                    return { from: p.dim_chunk_sel, to: p.dim_out_sel };\n                }\n                return { from: p.dim_chunk_sel, to: null };\n            });\n            yield { chunk_coords, mapping };\n        }\n    }\n}\n", "import { get_context } from \"../hierarchy.js\";\nimport { BasicIndexer } from \"./indexer.js\";\nimport { create_queue } from \"./util.js\";\nfunction unwrap(arr, idx) {\n    return (\"get\" in arr ? arr.get(idx) : arr[idx]);\n}\nexport async function get(arr, selection, opts, setter) {\n    let context = get_context(arr);\n    let indexer = new BasicIndexer({\n        selection,\n        shape: arr.shape,\n        chunk_shape: arr.chunks,\n    });\n    let out = setter.prepare(new context.TypedArray(indexer.shape.reduce((a, b) => a * b, 1)), indexer.shape, context.get_strides(indexer.shape));\n    let queue = opts.create_queue?.() ?? create_queue();\n    for (const { chunk_coords, mapping } of indexer) {\n        queue.add(async () => {\n            let { data, shape, stride } = await arr.getChunk(chunk_coords, opts.opts);\n            let chunk = setter.prepare(data, shape, stride);\n            setter.set_from_chunk(out, chunk, mapping);\n        });\n    }\n    await queue.onIdle();\n    // If the final out shape is empty, we just return a scalar.\n    // @ts-expect-error - TS can't narrow this conditional type\n    return indexer.shape.length === 0 ? unwrap(out.data, 0) : out;\n}\n", "import { get_context } from \"../hierarchy.js\";\nimport { BasicIndexer } from \"./indexer.js\";\nimport { create_queue } from \"./util.js\";\nfunction flip_indexer_projection(m) {\n    if (m.to == null)\n        return { from: m.to, to: m.from };\n    return { from: m.to, to: m.from };\n}\nexport async function set(arr, selection, value, opts, setter) {\n    const context = get_context(arr);\n    if (context.kind === \"sharded\") {\n        throw new Error(\"Set not supported for sharded arrays.\");\n    }\n    const indexer = new BasicIndexer({\n        selection,\n        shape: arr.shape,\n        chunk_shape: arr.chunks,\n    });\n    // We iterate over all chunks which overlap the selection and thus contain data\n    // that needs to be replaced. Each chunk is processed in turn, extracting the\n    // necessary data from the value array and storing into the chunk array.\n    const chunk_size = arr.chunks.reduce((a, b) => a * b, 1);\n    const queue = opts.create_queue ? opts.create_queue() : create_queue();\n    // N.B., it is an important optimisation that we only visit chunks which overlap\n    // the selection. This minimises the number of iterations in the main for loop.\n    for (const { chunk_coords, mapping } of indexer) {\n        const chunk_selection = mapping.map((i) => i.from);\n        const flipped = mapping.map(flip_indexer_projection);\n        queue.add(async () => {\n            // obtain key for chunk storage\n            const chunk_path = arr.resolve(context.encode_chunk_key(chunk_coords)).path;\n            let chunk_data;\n            const chunk_shape = arr.chunks.slice();\n            const chunk_stride = context.get_strides(chunk_shape);\n            if (is_total_slice(chunk_selection, chunk_shape)) {\n                // totally replace\n                chunk_data = new context.TypedArray(chunk_size);\n                // optimization: we are completely replacing the chunk, so no need\n                // to access the exisiting chunk data\n                if (typeof value === \"object\") {\n                    // Otherwise data just contiguous TypedArray\n                    const chunk = setter.prepare(chunk_data, chunk_shape.slice(), chunk_stride.slice());\n                    // @ts-expect-error - Value is not a scalar\n                    setter.set_from_chunk(chunk, value, flipped);\n                }\n                else {\n                    // @ts-expect-error - Value is a scalar\n                    chunk_data.fill(value);\n                }\n            }\n            else {\n                // partially replace the contents of this chunk\n                chunk_data = await arr.getChunk(chunk_coords).then(({ data }) => data);\n                const chunk = setter.prepare(chunk_data, chunk_shape.slice(), chunk_stride.slice());\n                // Modify chunk data\n                if (typeof value === \"object\") {\n                    // @ts-expect-error - Value is not a scalar\n                    setter.set_from_chunk(chunk, value, flipped);\n                }\n                else {\n                    setter.set_scalar(chunk, chunk_selection, value);\n                }\n            }\n            await arr.store.set(chunk_path, await context.codec.encode({\n                data: chunk_data,\n                shape: chunk_shape,\n                stride: chunk_stride,\n            }));\n        });\n    }\n    await queue.onIdle();\n}\nfunction is_total_slice(selection, shape) {\n    // all items are Indices and every slice is complete\n    return selection.every((s, i) => {\n        // can't be a full selection\n        if (typeof s === \"number\")\n            return false;\n        // explicit complete slice\n        const [start, stop, step] = s;\n        return stop - start === shape[i] && step === 1;\n    });\n}\n", "import { get as get_with_setter } from \"./get.js\";\nimport { set as set_with_setter } from \"./set.js\";\n/** A 1D \"view\" of an array that can be used to set values in the array. */\nfunction object_array_view(arr, offset = 0, size) {\n    let length = size ?? arr.length - offset;\n    return {\n        length,\n        subarray(from, to = length) {\n            return object_array_view(arr, offset + from, to - from);\n        },\n        set(data, start = 0) {\n            for (let i = 0; i < data.length; i++) {\n                arr[offset + start + i] = data.get(i);\n            }\n        },\n        get(index) {\n            return arr[offset + index];\n        },\n    };\n}\n/**\n * Convert a chunk to a Uint8Array that can be used with the binary\n * set functions. This is necessary because the binary set functions\n * require a contiguous block of memory, and allows us to support more than\n * just the browser's TypedArray objects.\n *\n * WARNING: This function is not meant to be used directly and is NOT type-safe.\n * In the case of `Array` instances, it will return a `object_array_view` of\n * the underlying, which is supported by our binary set functions.\n */\nfunction compat_chunk(arr) {\n    if (globalThis.Array.isArray(arr.data)) {\n        return {\n            // @ts-expect-error\n            data: object_array_view(arr.data),\n            stride: arr.stride,\n            bytes_per_element: 1,\n        };\n    }\n    return {\n        data: new Uint8Array(arr.data.buffer, arr.data.byteOffset, arr.data.byteLength),\n        stride: arr.stride,\n        bytes_per_element: arr.data.BYTES_PER_ELEMENT,\n    };\n}\n/** Hack to get the constructor of a typed array constructor from an existing TypedArray. */\nfunction get_typed_array_constructor(arr) {\n    if (\"chars\" in arr) {\n        // our custom TypedArray needs to bind the number of characters per\n        // element to the constructor.\n        return arr.constructor.bind(null, arr.chars);\n    }\n    return arr.constructor;\n}\n/**\n * Convert a scalar to a Uint8Array that can be used with the binary\n * set functions. This is necessary because the binary set functions\n * require a contiguous block of memory, and allows us to support more\n * than just the browser's TypedArray objects.\n *\n * WARNING: This function is not meant to be used directly and is NOT type-safe.\n * In the case of `Array` instances, it will return a `object_array_view` of\n * the scalar, which is supported by our binary set functions.\n */\nfunction compat_scalar(arr, value) {\n    if (globalThis.Array.isArray(arr.data)) {\n        // @ts-expect-error\n        return object_array_view([value]);\n    }\n    let TypedArray = get_typed_array_constructor(arr.data);\n    // @ts-expect-error - value is a scalar and matches\n    let data = new TypedArray([value]);\n    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n}\nexport const setter = {\n    prepare(data, shape, stride) {\n        return { data, shape, stride };\n    },\n    set_scalar(dest, sel, value) {\n        let view = compat_chunk(dest);\n        set_scalar_binary(view, sel, compat_scalar(dest, value), view.bytes_per_element);\n    },\n    set_from_chunk(dest, src, projections) {\n        let view = compat_chunk(dest);\n        set_from_chunk_binary(view, compat_chunk(src), view.bytes_per_element, projections);\n    },\n};\n/** @category Utility */\nexport async function get(arr, selection = null, opts = {}) {\n    return get_with_setter(arr, selection, opts, setter);\n}\n/** @category Utility */\nexport async function set(arr, selection, value, opts = {}) {\n    return set_with_setter(arr, selection, value, opts, setter);\n}\nfunction indices_len(start, stop, step) {\n    if (step < 0 && stop < start) {\n        return Math.floor((start - stop - 1) / -step) + 1;\n    }\n    if (start < stop)\n        return Math.floor((stop - start - 1) / step) + 1;\n    return 0;\n}\nfunction set_scalar_binary(out, out_selection, value, bytes_per_element) {\n    if (out_selection.length === 0) {\n        out.data.set(value, 0);\n        return;\n    }\n    const [slice, ...slices] = out_selection;\n    const [curr_stride, ...stride] = out.stride;\n    if (typeof slice === \"number\") {\n        const data = out.data.subarray(curr_stride * slice * bytes_per_element);\n        set_scalar_binary({ data, stride }, slices, value, bytes_per_element);\n        return;\n    }\n    const [from, to, step] = slice;\n    const len = indices_len(from, to, step);\n    if (slices.length === 0) {\n        for (let i = 0; i < len; i++) {\n            out.data.set(value, curr_stride * (from + step * i) * bytes_per_element);\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        const data = out.data.subarray(curr_stride * (from + step * i) * bytes_per_element);\n        set_scalar_binary({ data, stride }, slices, value, bytes_per_element);\n    }\n}\nfunction set_from_chunk_binary(dest, src, bytes_per_element, projections) {\n    const [proj, ...projs] = projections;\n    const [dstride, ...dstrides] = dest.stride;\n    const [sstride, ...sstrides] = src.stride;\n    if (proj.from === null) {\n        if (projs.length === 0) {\n            dest.data.set(src.data.subarray(0, bytes_per_element), proj.to * bytes_per_element);\n            return;\n        }\n        set_from_chunk_binary({\n            data: dest.data.subarray(dstride * proj.to * bytes_per_element),\n            stride: dstrides,\n        }, src, bytes_per_element, projs);\n        return;\n    }\n    if (proj.to === null) {\n        if (projs.length === 0) {\n            let offset = proj.from * bytes_per_element;\n            dest.data.set(src.data.subarray(offset, offset + bytes_per_element), 0);\n            return;\n        }\n        set_from_chunk_binary(dest, {\n            data: src.data.subarray(sstride * proj.from * bytes_per_element),\n            stride: sstrides,\n        }, bytes_per_element, projs);\n        return;\n    }\n    const [from, to, step] = proj.to;\n    const [sfrom, _, sstep] = proj.from;\n    const len = indices_len(from, to, step);\n    if (projs.length === 0) {\n        // NB: we have a contiguous block of memory\n        // so we can just copy over all the data at once.\n        if (step === 1 && sstep === 1 && dstride === 1 && sstride === 1) {\n            let offset = sfrom * bytes_per_element;\n            let size = len * bytes_per_element;\n            dest.data.set(src.data.subarray(offset, offset + size), from * bytes_per_element);\n            return;\n        }\n        // Otherwise, we have to copy over each element individually.\n        for (let i = 0; i < len; i++) {\n            let offset = sstride * (sfrom + sstep * i) * bytes_per_element;\n            dest.data.set(src.data.subarray(offset, offset + bytes_per_element), dstride * (from + step * i) * bytes_per_element);\n        }\n        return;\n    }\n    for (let i = 0; i < len; i++) {\n        set_from_chunk_binary({\n            data: dest.data.subarray(dstride * (from + i * step) * bytes_per_element),\n            stride: dstrides,\n        }, {\n            data: src.data.subarray(sstride * (sfrom + i * sstep) * bytes_per_element),\n            stride: sstrides,\n        }, bytes_per_element, projs);\n    }\n}\n", "import { KeyError, NodeNotFoundError } from \"./errors.js\";\nimport { assert, json_decode_object, json_encode_object, rethrow_unless, } from \"./util.js\";\nasync function get_consolidated_metadata(store) {\n    let bytes = await store.get(\"/.zmetadata\");\n    if (!bytes) {\n        throw new NodeNotFoundError(\"v2 consolidated metadata\", {\n            cause: new KeyError(\"/.zmetadata\"),\n        });\n    }\n    let meta = json_decode_object(bytes);\n    assert(meta.zarr_consolidated_format === 1, \"Unsupported consolidated format.\");\n    return meta;\n}\nfunction is_meta_key(key) {\n    return (key.endsWith(\".zarray\") ||\n        key.endsWith(\".zgroup\") ||\n        key.endsWith(\".zattrs\") ||\n        key.endsWith(\"zarr.json\"));\n}\nfunction is_v3(meta) {\n    return \"zarr_format\" in meta && meta.zarr_format === 3;\n}\n/**\n * Open a consolidated store.\n *\n * This will open a store with Zarr v2 consolidated metadata (`.zmetadata`).\n * @see {@link https://zarr.readthedocs.io/en/stable/spec/v2.html#consolidated-metadata}\n *\n * @param store The store to open.\n * @returns A listable store.\n *\n * @example\n * ```js\n * let store = await withConsolidated(\n *   new zarr.FetchStore(\"https://my-bucket.s3.amazonaws.com\");\n * );\n * store.contents(); // [{ path: \"/\", kind: \"group\" }, { path: \"/foo\", kind: \"array\" }, ...]\n * let grp = zarr.open(store); // Open the root group.\n * let foo = zarr.open(grp.resolve(contents[1].path)); // Open the foo array\n * ```\n */\nexport async function withConsolidated(store) {\n    let v2_meta = await get_consolidated_metadata(store);\n    let known_meta = {};\n    for (let [key, value] of Object.entries(v2_meta.metadata)) {\n        known_meta[`/${key}`] = value;\n    }\n    return {\n        async get(...args) {\n            let [key, opts] = args;\n            if (known_meta[key]) {\n                return json_encode_object(known_meta[key]);\n            }\n            let maybe_bytes = await store.get(key, opts);\n            if (is_meta_key(key) && maybe_bytes) {\n                let meta = json_decode_object(maybe_bytes);\n                known_meta[key] = meta;\n            }\n            return maybe_bytes;\n        },\n        // Delegate range requests to the underlying store.\n        // Note: Supporting range requests for consolidated metadata is possible\n        // but unlikely to be useful enough to justify the effort.\n        getRange: store.getRange?.bind(store),\n        contents() {\n            let contents = [];\n            for (let [key, value] of Object.entries(known_meta)) {\n                let parts = key.split(\"/\");\n                let filename = parts.pop();\n                let path = (parts.join(\"/\") || \"/\");\n                if (filename === \".zarray\")\n                    contents.push({ path, kind: \"array\" });\n                if (filename === \".zgroup\")\n                    contents.push({ path, kind: \"group\" });\n                if (is_v3(value)) {\n                    contents.push({ path, kind: value.node_type });\n                }\n            }\n            return contents;\n        },\n    };\n}\n/**\n * Try to open a consolidated store, but fall back to the original store if the\n * consolidated metadata is missing.\n *\n * Provides a convenient way to open a store that may or may not have consolidated,\n * returning a consistent interface for both cases. Ideal for usage senarios with\n * known access paths, since store with consolidated metadata do not incur\n * additional network requests when accessing underlying groups and arrays.\n *\n * @param store The store to open.\n * @returns A listable store.\n */\nexport async function tryWithConsolidated(store) {\n    return withConsolidated(store).catch((error) => {\n        rethrow_unless(error, NodeNotFoundError);\n        return store;\n    });\n}\n", "import type { AbsolutePath } from \"./types.js\";\n\nexport function strip_prefix<Path extends AbsolutePath>(\n\tpath: Path,\n): Path extends AbsolutePath<infer Rest> ? Rest : never {\n\t// @ts-expect-error - TS can't infer this type correctly\n\treturn path.slice(1);\n}\n\nexport function uri2href(url: string | URL) {\n\tlet [protocol, rest] = (typeof url === \"string\" ? url : url.href).split(\n\t\t\"://\",\n\t);\n\tif (protocol === \"https\" || protocol === \"http\") {\n\t\treturn url;\n\t}\n\tif (protocol === \"gc\") {\n\t\treturn `https://storage.googleapis.com/${rest}`;\n\t}\n\tif (protocol === \"s3\") {\n\t\treturn `https://s3.amazonaws.com/${rest}`;\n\t}\n\tthrow Error(`Protocol not supported, got: ${JSON.stringify(protocol)}`);\n}\n\nexport function fetch_range(\n\turl: string | URL,\n\toffset?: number,\n\tlength?: number,\n\topts: RequestInit = {},\n) {\n\tif (offset !== undefined && length !== undefined) {\n\t\t// merge request opts\n\t\topts = {\n\t\t\t...opts,\n\t\t\theaders: {\n\t\t\t\t...opts.headers,\n\t\t\t\tRange: `bytes=${offset}-${offset + length - 1}`,\n\t\t\t},\n\t\t};\n\t}\n\treturn fetch(url, opts);\n}\n\nexport function merge_init(\n\tstoreOverrides: RequestInit,\n\trequestOverrides: RequestInit,\n) {\n\t// Request overrides take precedence over storeOverrides.\n\treturn {\n\t\t...storeOverrides,\n\t\t...requestOverrides,\n\t\theaders: {\n\t\t\t...storeOverrides.headers,\n\t\t\t...requestOverrides.headers,\n\t\t},\n\t};\n}\n\n/**\n * Make an assertion.\n *\n * Usage\n * @example\n * ```ts\n * const value: boolean = Math.random() <= 0.5;\n * assert(value, \"value is greater than than 0.5!\");\n * value // true\n * ```\n *\n * @param expression - The expression to test.\n * @param msg - The optional message to display if the assertion fails.\n * @throws an {@link Error} if `expression` is not truthy.\n */\nexport function assert(\n\texpression: unknown,\n\tmsg: string | undefined = \"\",\n): asserts expression {\n\tif (!expression) throw new Error(msg);\n}\n", "import type { AbsolutePath, AsyncReadable, RangeQuery } from \"./types.js\";\nimport { fetch_range, merge_init } from \"./util.js\";\n\nfunction resolve(root: string | URL, path: AbsolutePath): URL {\n\tconst base = typeof root === \"string\" ? new URL(root) : root;\n\tif (!base.pathname.endsWith(\"/\")) {\n\t\t// ensure trailing slash so that base is resolved as _directory_\n\t\tbase.pathname += \"/\";\n\t}\n\tconst resolved = new URL(path.slice(1), base);\n\t// copy search params to new URL\n\tresolved.search = base.search;\n\treturn resolved;\n}\n\nasync function handle_response(\n\tresponse: Response,\n): Promise<Uint8Array | undefined> {\n\tif (response.status === 404) {\n\t\treturn undefined;\n\t}\n\tif (response.status === 200 || response.status === 206) {\n\t\treturn new Uint8Array(await response.arrayBuffer());\n\t}\n\tthrow new Error(\n\t\t`Unexpected response status ${response.status} ${response.statusText}`,\n\t);\n}\n\nasync function fetch_suffix(\n\turl: URL,\n\tsuffix_length: number,\n\tinit: RequestInit,\n\tuse_suffix_request: boolean,\n): Promise<Response> {\n\tif (use_suffix_request) {\n\t\treturn fetch(url, {\n\t\t\t...init,\n\t\t\theaders: { ...init.headers, Range: `bytes=-${suffix_length}` },\n\t\t});\n\t}\n\tlet response = await fetch(url, { ...init, method: \"HEAD\" });\n\tif (!response.ok) {\n\t\t// will be picked up by handle_response\n\t\treturn response;\n\t}\n\tlet content_length = response.headers.get(\"Content-Length\");\n\tlet length = Number(content_length);\n\treturn fetch_range(url, length - suffix_length, length, init);\n}\n\n/**\n * Readonly store based in the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n * Must polyfill `fetch` for use in Node.js.\n *\n * ```typescript\n * import * as zarr from \"zarrita\";\n * const store = new FetchStore(\"http://localhost:8080/data.zarr\");\n * const arr = await zarr.get(store, { kind: \"array\" });\n * ```\n */\nclass FetchStore implements AsyncReadable<RequestInit> {\n\t#overrides: RequestInit;\n\t#use_suffix_request: boolean;\n\n\tconstructor(\n\t\tpublic url: string | URL,\n\t\toptions: { overrides?: RequestInit; useSuffixRequest?: boolean } = {},\n\t) {\n\t\tthis.#overrides = options.overrides ?? {};\n\t\tthis.#use_suffix_request = options.useSuffixRequest ?? false;\n\t}\n\n\t#merge_init(overrides: RequestInit) {\n\t\treturn merge_init(this.#overrides, overrides);\n\t}\n\n\tasync get(\n\t\tkey: AbsolutePath,\n\t\toptions: RequestInit = {},\n\t): Promise<Uint8Array | undefined> {\n\t\tlet href = resolve(this.url, key).href;\n\t\tlet response = await fetch(href, this.#merge_init(options));\n\t\treturn handle_response(response);\n\t}\n\n\tasync getRange(\n\t\tkey: AbsolutePath,\n\t\trange: RangeQuery,\n\t\toptions: RequestInit = {},\n\t): Promise<Uint8Array | undefined> {\n\t\tlet url = resolve(this.url, key);\n\t\tlet init = this.#merge_init(options);\n\t\tlet response: Response;\n\t\tif (\"suffixLength\" in range) {\n\t\t\tresponse = await fetch_suffix(\n\t\t\t\turl,\n\t\t\t\trange.suffixLength,\n\t\t\t\tinit,\n\t\t\t\tthis.#use_suffix_request,\n\t\t\t);\n\t\t} else {\n\t\t\tresponse = await fetch_range(url, range.offset, range.length, init);\n\t\t}\n\t\treturn handle_response(response);\n\t}\n}\n\nexport default FetchStore;\n"],
  "mappings": "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",
  "names": ["bytes_per_element", "_shape", "_a", "root", "_a", "native_order", "_metadata", "Array", "Array", "Array", "setter", "_a", "setter", "get", "set", "bytes_per_element", "slice", "_a", "root", "range"]
}
